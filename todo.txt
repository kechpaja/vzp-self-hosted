Start optimizing stuff, and figure out how to emit LLVM!

And not to mention typechecking, of course.


Remember to use ulimit to set stack size limit, and --stack-size to node as
well. Currently it works with a stack size of 9000 kb, but I'd like to try and
bring this down to where I don't have to up the limit anymore.


One thing we eventually need to do is re-configure the tokenizer so that a
program of the form

let f = +
f(1,2)

is regarded as acceptable. Basically, this means not automatically deleting the
semicolon after + when it's preceded by =, but it's a low-priority change
because you can get around it easily by putting the + in parentheses.



For typechecking: 

We need to figure out how to handle imports. There are a couple of options, and
they're all pretty obvious, but there's some thinking to be done before we
commit to one. 

We should be removing the type information from lambda params before we get to
transform. There will probably be a "deoverload" step or something like that,
and that would be the obvious place to do that.

Remove typechecking from corefuncs once more of these problems are solved. For
now, it's not safe to do so. 



For transform: the algorithm needs to be re-thought, since it currently fails
for a number of cases (not yet represented in the tests) in which there are
several nested layers of ifs, lets, and other constructions in a lettable
position.


For defunc: consider not putting references to builtin functions into closure.

We also need to change the builtins so that they can be called in the familiar
fashion (or not). Alternatively, we can have a second env keeping track of
which functions close over variables or not. The latter is probably the best
choice, especially as it will allow for more optimization when we target LLVM.

Okay, so the additional layer of typing (determine whether we need to pass a
closure for a particular function or not) is the eventual goal, but for now it
requires a lot of steps that I'm not ready to do yet. For now, then, we are
going to create a primitive closure whenever a builtin is looked up, and then
we're going to change it later when we have a smarter system for handling
imports. 




Maybe eventually complain if there are unreachable tokens in the file? 
