Start optimizing stuff, and figure out how to emit LLVM!

Remember to use ulimit to set stack size limit, and --stack-size to node as
well. Currently it works with a stack size of 5000 kb, but I'd like to try and
bring this down to where I don't have to up the limit anymore.


One thing we eventually need to do is re-configure the tokenizer so that a
program of the form

let f = +
f(1,2)

is regarded as acceptable. Basically, this means not automatically deleting the
semicolon after + when it's preceded by =, but it's a low-priority change
because you can get around it easily by putting the + in parentheses.



For typechecking: 

Imports are handled, but it might be a good idea to allow for linking to files
that aren't going to be included in the binary or JS output. Need to think
about how to make sure we get the type information we need. 

Remove typechecking from corefuncs once more of these problems are solved. For
now, it's not safe to do so.

In the long run, we can probably get rid of the corefuncs file entirely, and
just generate lightweight functions for the builtings when they are used in a
context where they can't be emited as operators in JS or LLVM.

Semi-tangentially, we need to think about the syntax for user-defined types a
bit more. There's some room for variation there, but also no need to go too far
overboard. 

If the typechecker can catch and reject (some) infinite loops, that would be
useful.  

I don't think we're currently handling multi-level types, where fields in the
more generic type should also be reflected in the subtype constructors. This
will have to change in the new typechecker, but for now I think it's better
punted on.

Do we need an else case in the switch statement? Probably. That needs to be
added in the parser. There's also a bunch of stuff to do in typecheck.vzp for
that, although I'm going to wait for another day.

Currently, we're doing something wrong when typechecking return types --- we
get an exception when we should see a type mismatch.

Eventually, we'll need to remove [] entirely, but we can't do that until we
type object fields. Once we do that, we can also get rid of the corefuncs __43_
function, since it will no longer be possible to add two things that don't have
a defined type.



For transform, consider not duplicating code in conditionals, as it can make
the program grow immensely. 

Short circuiting currently happens on *all* boolean binops, including things
like (&&)(x, y) (although not if the operation was passed somewhere as a
function). We are going to have to use the type system to enforce that things
with side effects can't be used on either side of a boolean operator. 


Maybe eventually complain if there are unreachable tokens in the file?


There are also a handful of syntactic changes that I would like to implement at
some point, but those need to be batched as they will require a fair bit of
work on my part to change things in the compiler. For now, the ones I'm
thinking of are:

 - The + operator should no longer be overloaded. Possibly continue to allow it
   to be overloaded when called directly on two arrays, but when passed as a
   function it should always be for numbers only.

 - Array access should no longer use :. Consider either more traditional syntax
   or treating arrays as callable on integers; the latter may be preferable
   since it allows us to use $ and other functions.

 - Require a comma between the second and third arguments of @> and <@.

 - More that I can't think of right now.



We should probably allow empty objects? Or is that silly?



Some other long-term ideas:

 - Build in easy serialization, by storing the fields and expected types of a
   user-defined type. Should be able to output JSON with a single line.
