import utils

let isLetterOrUnderscore = (c :: Int64) =>
    c == 95 || (c <= 122 && 97 <= c) || (c <= 90 && 65 <= c)

let isDigit = (c :: Int64) => c <= 57 && 48 <= c

let isLetterDigitOrUnderscore = (c :: Int64) => 
    isLetterOrUnderscore(c) || isDigit(c)

let isEOL = (c :: Int64) => c == 10 || c == 13 || c == 59 /* \n, \r, ; */

let charsGoTogether = (a :: [Int64], b :: Int64) =>
    if a == "" then true else
        ((a:0 == 34) && (if length(a) == 1 then true else if a == "" then false
                         else ((a:(length(a)-1) != 34)||(a:(length(a)-2) == 92))))
     || (isLetterOrUnderscore(a:0) && isLetterDigitOrUnderscore(b))
     || (isDigit(a:0) && isDigit(b))
     || (isEOL(a:0) && isEOL(b))
     || (a == ":" && b == 58)
     || ((a == "=" || a == "<" || a == ">" || a == "!") && b == 61)
     || (a == "=" && b == 62) || (a == "!" && b == 61)
     || (a == "<" && b == 64) || (a == "@" && b == 62)
     || (a == "|" && b == 124) || (a == "&" && b == 38)
     || (a == "." && b == 46) || (a == "/" && b == 42)
     || (a == "|" && b == 62) || (a == "<" && b == 124)
     || (a == "-" && b == 62) || (a == "+" && b == 43)
     || (a == "<" && b == 47) || (a == "/" && b == 62)
     || (if length(a) >= 2 then (a:(0..2)) == "/*"
                       && (a:((length(a)-2)..length(a))) !="*/" else false)

/* whitespace != \n, \r */
let skip = (c :: Int64) => (c <= 32) && (c != 10) && (c != 13)

let tokenize = (currentTokenPart :: [Int64], chars :: [Int64]) =>
    if length(chars) <= 0 then
        if currentTokenPart == "" then [] else [currentTokenPart]
    else if length(chars) == 1 then
        if charsGoTogether(currentTokenPart, chars : 0) then
            [currentTokenPart + chars]
        else if skip(chars : 0) then
            [currentTokenPart]
        else
            [currentTokenPart] + [chars]
    else
        if charsGoTogether(currentTokenPart, chars : 0) then
            recur(currentTokenPart + chars : [0], chars : 1..length(chars))
        else if skip(chars : 0) then
            [currentTokenPart] + recur("", chars : 1..length(chars))
        else
            [currentTokenPart] + recur(chars : [0], chars : 1..length(chars))

let simplifyToken = (t :: [Int64]) => if isEOL(t:0) then ";" else t

/* Stuff for removing unnecessary tokens */
let mergeKeywords = ["==", "!=", "<", "<=", ">", ">=", "||", "&&", ".", "..", 
                     ":", "+", "++", "-", "/", "*", "%", "@>", "<@", "$", "=>",
                     ",", ";", "then", "else", "as", "::", "->"]
let mergeKeywordsBefore = ["if", "import", "let", "(", "[", "{", "<|"] 
                                                                + mergeKeywords
let mergeKeywordsAfter = ["|>", ")", "}", "]"] + mergeKeywords

let merge = (token :: [Int64], list :: [[Int64]]) =>
    if length(token) >= 2 && (token:(0..2)) == "/*" then list else
    if length(list) == 0 && token == ";" then [] else
    if length(list) == 0 then [token] else
    if token == " " then list else
    if utils.in(token, mergeKeywordsBefore) && ((list:0) == ";") then 
        [token] + (if length(list) > 1 then (list:(1..length(list))) else [])
    else if utils.in(list:0, mergeKeywordsAfter) && token == ";" then
        list
    else
        [token] + list

/* Just export this function */
(program :: [Int64]) =>
    let tokens = merge @> (simplifyToken $ tokenize("", program)) []
    if length(tokens) > 0 && (tokens:0 == ";") then 
        (tokens:(1..length(tokens)))
    else
        tokens
