import utils

let isLetterOrUnderscore = (c :: Int64) =>
    c == 95 || (c <= 122 && 97 <= c) || (c <= 90 && 65 <= c)

let isDigit = (c :: Int64) => c <= 57 && 48 <= c

let isLetterDigitOrUnderscore = (c :: Int64) => 
    isLetterOrUnderscore(c) || isDigit(c)

let isEOL = (c :: Int64) => c == 10 || c == 13 || c == 59 /* \n, \r, ; */

let charsGoTogether = (a :: [Int64], b :: Int64) =>
    if a == "" then true else /* Need if because still no short circuiting*/
        ((a:0 == 34) && (if a.length == 1 then true else if a == "" then false
                         else ((a:(a.length-1) != 34)||(a:(a.length-2) == 92))))
     || (isLetterOrUnderscore(a:0) && isLetterDigitOrUnderscore(b))
     || (isDigit(a:0) && isDigit(b))
     || (isEOL(a:0) && isEOL(b))
     || (a == ":" && b == 58)
     || ((a == "=" || a == "<" || a == ">" || a == "!") && b == 61)
     || (a == "=" && b == 62) || (a == "!" && b == 61)
     || (a == "<" && b == 64) || (a == "@" && b == 62)
     || (a == "|" && b == 124) || (a == "&" && b == 38)
     || (a == "." && b == 46) || (a == "/" && b == 42)
     || (if a.length >= 2 then (a:(0..1)) == "/*" /* Again, no short circuit */
                       && (a:((a.length-2)..(a.length-1))) !="*/" else false)

/* whitespace != \n, \r */
let skip = (c :: Int64) => (c <= 32) && (c != 10) && (c != 13)

let tokenize = (currentTokenPart :: [Int64], chars :: [Int64]) =>
    if chars.length <= 0 then
        if currentTokenPart == "" then [] else [currentTokenPart]
    else if chars.length == 1 then
        if charsGoTogether(currentTokenPart, chars : 0) then
            [currentTokenPart + chars]
        else if skip(chars : 0) then
            [currentTokenPart]
        else
            [currentTokenPart] + [chars]
    else
        if charsGoTogether(currentTokenPart, chars : 0) then
            recur(currentTokenPart + chars : [0], chars : 1..(chars.length-1))
        else if skip(chars : 0) then
            [currentTokenPart] + recur("", chars : 1..(chars.length-1))
        else
            [currentTokenPart] + recur(chars : [0], chars : 1..(chars.length-1))

let simplifyToken = (t :: [Int64]) => if isEOL(t:0) then ";" else t

/* Stuff for removing unnecessary tokens */
let mergeKeywords = ["==", "!=", "<", "<=", ">", ">=", "||", "&&", ".", "..", 
                     ":", "+", "-", "/", "*", "%", "@>", "<@", "$", "=>", ",",
                     ";", "then", "else", "as", "::"]
let mergeKeywordsBefore = ["if", "import", "let", "(", "[", "{"] + mergeKeywords
let mergeKeywordsAfter = [")", "}", "]"] + mergeKeywords

let merge = (token :: [Int64], list :: [[Int64]]) =>
    if token.length >= 2 && (token:(0..1)) == "/*" then list else
    if list.length == 0 && token == ";" then [] else
    if list.length == 0 then [token] else
    if token == " " then list else
    if utils.in(token, mergeKeywordsBefore) && ((list:0) == ";") then 
        [token] + (if list.length > 1 then (list:(1..(list.length-1))) else [])
    else if utils.in(list:0, mergeKeywordsAfter) && token == ";" then
        list
    else
        [token] + list

/* Just export this function */
(program :: [Int64]) =>
    let tokens = merge @> (simplifyToken $ tokenize("", program)) []
    if tokens.length > 0 && (tokens:0 == ";") then 
        (tokens:(1..(tokens.length-1)))
    else
        tokens
