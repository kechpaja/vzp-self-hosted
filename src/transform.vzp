import IdValuePair
import TransformedAst
import desugar
import utils

let restOf = (x :: [Object]) => if x.length <= 1 then [] else x:1..(x.length-1)

let ctoid = (x :: Int64) => "i" + utils.itoa(x)

/* Run through AST and add something to IDs to make them unique */
let uniqueIds = (astOuter :: Object) =>
    ((ast :: Object, env :: [Object], count :: Int64) =>
        let replaceIfInEnv = (id :: [Int64], e :: [Object]) =>
            if e == [] then id else 
            if (e:0).orig == id then (e:0).new else recur(id, restOf(e))
        let appendToEnv = (orig :: [Int64], new :: [Int64], e :: [Object]) =>
            [{ orig: orig, new: new }] + e

        let recFunc = recur
        let argRec = (args :: [Object], c :: Int64) =>
            let f = (x :: Object, saved :: Object) =>
                let arg = recFunc(x, env, saved.count)
                { ast: [arg.ast] + saved.ast, count: arg.count }
            f @> args { ast: [], count: c }

        if ast.type == "array" then
            let contents = argRec(ast.contents, count)
            { ast: { type: "array",
                     contents: contents.ast },
              count: contents.count }
        else if ast.type == "assignment" then
            let value = recur(ast.value, env, count + 1)
            let body = recur(ast.body,
                             appendToEnv(ast.identifier,
                                         ctoid(count),
                                         env),
                             value.count)
            { ast: { type: "assignment",
                     identifier: ctoid(count),
                     value: value.ast,
                     body: body.ast },
              count: body.count }
        else if ast.type == "call" then
            let func = recur(ast.func, env, count)
            let args = argRec(ast.args, func.count)
            { ast: { type: "call",
                     func: func.ast,
                     args: args.ast },
              count: args.count }
        else if ast.type == "conditional" then
            let cond = recur(ast.cond, env, count)
            let thn = recur(ast.thn, env, cond.count)
            let els = recur(ast.els, env, thn.count)
            { ast: { type: "conditional",
                     cond: cond.ast,
                     thn: thn.ast,
                     els: els.ast },
              count: els.count }
        else if ast.type == "field_access" then
            let obj = recur(ast.obj, env, count)
            { ast: { type: "field_access",
                     obj: obj.ast,
                     field: ast.field },
              count: obj.count }
        else if ast.type == "lambda" then
            let augmentEnv = (params :: [[Int64]], e :: [Object], c :: Int64) =>
                let ln = params.length
                if ln == 0 then e else
                if ln == 1 then appendToEnv(params:0, ctoid(c), e) else
                appendToEnv(params:0, ctoid(c), recur(params:1..(ln-1), e, c+1))

            let newEnv = augmentEnv(ast.params, env, count)
            let body = recur(ast.body, newEnv, count + ast.params.length)
            { ast: { type: "lambda",
                     params: ((x :: [Int64]) => 
                                  replaceIfInEnv(x, newEnv)) $ ast.params,
                     body: body.ast },
              count: body.count }
        else if ast.type == "lookup" then
            { ast: { type: "lookup",
                     identifier: replaceIfInEnv(ast.identifier, env) },
              count: count }
        else if ast.type == "object" then
            let f = (pair :: Object, saved :: Object) =>
                let newValue = recFunc(pair.value, env, saved.count)
                let newPair = { identifier: pair.identifier,
                                value: newValue.ast }
                { ast: [newPair] + saved.ast, count: newValue.count }

            let contents = f @> ast.contents { ast: [], count: count }
            { ast: { type: "object", contents: contents.ast },
              count: contents.count }
        else
            { ast: ast, count: count })(astOuter, [], 0).ast

let idfunc = (x :: TransformedAst) => x

let transform_main = (ast :: Object,
                      binder :: (TransformedAst) TransformedAst) =>
    let recFunc = recur
    let doList = (f :: (Object, (TransformedAst) TransformedAst) TransformedAst,
                  list :: [Object],
                  new :: [TransformedAst],
                  b :: ([TransformedAst]) TransformedAst) =>
        if list == [] then b(new) else
        let innerRec = recur
        f(list:0,
          (x :: TransformedAst) => innerRec(f, restOf(list), new + [x], b))

    if ast.type == "array" then
        doList(recur,
               ast.contents,
               [],
               (x :: [TransformedAst]) => binder(TransformedAst.array(x)))
    else if ast.type == "assignment" then
        let body = recur(ast.body, binder)
        recur(ast.value, (x :: TransformedAst) =>
                            TransformedAst.assignment(ast.identifier, x, body))
    else if ast.type == "call" then
        recur(ast.func, (func :: TransformedAst) => doList(
            recFunc,
            ast.args,
            [],
            (args :: [TransformedAst]) => binder(TransformedAst.call(func,args))
        ))
    else if ast.type == "conditional" then
        let thn = recur(ast.thn, binder)
        let els = recur(ast.els, binder)
        recur(ast.cond, (x :: TransformedAst) => 
                            TransformedAst.conditional(x, thn, els))
    else if ast.type == "field_access" then
        recur(ast.obj, (x :: TransformedAst) =>
                            binder(TransformedAst.field_access(x, ast.field)))
    else if ast.type == "lambda" then
        binder(TransformedAst.lambda(ast.params, recur(ast.body, idfunc)))
    else if ast.type == "lookup" then
        binder(TransformedAst.lookup(ast.identifier))
    else if ast.type == "number" then
        binder(TransformedAst.number(ast.value))
    else /* Has to be an object if we get here */
        let f = (pair :: Object,
                 b :: (TransformedAst) TransformedAst) => recFunc(
            pair.value, 
            (x :: TransformedAst) => 
                b(IdValuePair</TransformedAst/>(pair.identifier, x))
        )
        doList(f, ast.contents, [], (x :: TransformedAst) => 
                                        binder(TransformedAst.object(x)))

(program_as_string :: [Int64]) =>
    transform_main(uniqueIds(desugar(program_as_string)), (x :: TransformedAst) => x)
