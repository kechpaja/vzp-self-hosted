import DesugaredAst
import IdValuePair
import TransformedAst
import desugar
import utils

let ctoid = (x :: Int64) => "i" + utils.itoa(x)

let UniquedWrapper = type {
    ast :: DesugaredAst,
    count :: Int64
}

let UniquedListWrapper = type {
    ast :: [DesugaredAst],
    count :: Int64
}

let UniquedObjectListWrapper = type {
    ast :: [IdValuePair</DesugaredAst/>],
    count :: Int64
}

/* Run through AST and add something to IDs to make them unique */
let uniqueIds = (astOuter :: DesugaredAst) =>
    ((ast :: DesugaredAst, env :: [IdValuePair</[Int64]/>], count :: Int64) =>
        let replaceIfInEnv = (id :: [Int64], e :: [IdValuePair</[Int64]/>]) =>
            if e == [] then id else 
            if (e:0).identifier == id then (e:0).value
                                      else recur(id, e:1..length(e))
        let appendToEnv = (orig :: [Int64],
                           new :: [Int64],
                           e :: [IdValuePair</[Int64]/>]) =>
            [IdValuePair</[Int64]/>(orig, new)] + e

        let recFunc = recur
        let argRec = (args :: [DesugaredAst],
                      c :: Int64) :: UniquedListWrapper =>
            let f = (saved :: UniquedListWrapper,
                     x :: DesugaredAst) :: UniquedListWrapper =>
                let arg = recFunc(x, env, saved.count)
                UniquedListWrapper(saved.ast + [arg.ast], arg.count)
            args ^ UniquedListWrapper([], c) @ f

        switch ast <|
            DesugaredAst.array ->
                let contents = argRec(that.contents, count)
                UniquedWrapper(DesugaredAst.array(contents.ast), contents.count),
            DesugaredAst.assignment ->
                let value = recur(that.value, env, count + 1)
                let body = recur(that.body,
                                 appendToEnv(that.identifier,
                                             ctoid(count),
                                             env),
                                 value.count)
                UniquedWrapper(
                    DesugaredAst.assignment(ctoid(count), value.ast, body.ast),
                    body.count
                ),
            DesugaredAst.call ->
                let fn = recur(that.func, env, count)
                let args = argRec(that.args, fn.count)
                UniquedWrapper(DesugaredAst.call(fn.ast, args.ast), args.count),
            DesugaredAst.conditional ->
                let c = recur(that.cond, env, count)
                let t = recur(that.thn, env, c.count)
                let e = recur(that.els, env, t.count)
                UniquedWrapper(DesugaredAst.conditional(c.ast, t.ast, e.ast),
                               e.count),
            DesugaredAst.field_access ->
                let obj = recur(that.obj, env, count)
                UniquedWrapper(DesugaredAst.field_access(obj.ast, that.field),
                               obj.count),
            DesugaredAst.lambda ->
                let augmentEnv = (params :: [[Int64]],
                                  e :: [IdValuePair</[Int64]/>],
                                  c :: Int64) =>
                    let ln = length(params)
                    if ln == 0 then e else
                    if ln == 1 then appendToEnv(params:0, ctoid(c), e) else
                    appendToEnv(params:0, ctoid(c), recur(params:1..ln, e, c+1))
                let newEnv = augmentEnv(that.params, env, count)
                let body = recur(that.body, newEnv, count + length(that.params))
                UniquedWrapper(DesugaredAst.lambda(
                    ((x :: [Int64]) => replaceIfInEnv(x, newEnv)) $ that.params,
                    body.ast
                ), body.count),
            DesugaredAst.lookup ->
                UniquedWrapper(
                    DesugaredAst.lookup(replaceIfInEnv(that.identifier, env)),
                    count
                ),
            DesugaredAst.number ->
                UniquedWrapper(DesugaredAst.number(that.value), count),
            DesugaredAst.object ->
                /* TODO We need this lambda for the return type right now, since
                 * reduces are of type narrowest. But we can remove it when type
                 * variables are working and reducers are no longer always of
                 * type narrowest. */
                let genContents = (
                    list :: [IdValuePair</DesugaredAst/>]
                ) :: UniquedObjectListWrapper =>
                    list ^ UniquedObjectListWrapper(
                        [],
                        count
                    ) @ (
                        saved :: UniquedObjectListWrapper,
                        pair :: IdValuePair</DesugaredAst/>
                    ) :: UniquedObjectListWrapper =>
                        let newValue = recFunc(pair.value, env, saved.count)
                        let newPair = IdValuePair</DesugaredAst/>(
                            pair.identifier,
                            newValue.ast
                        )
                        UniquedObjectListWrapper(saved.ast + [newPair],
                                                 newValue.count)
                let contents = genContents(that.contents)
                UniquedWrapper(DesugaredAst.object(contents.ast),
                               contents.count)
        |>)(astOuter, [], 0).ast

let idfun = (x :: TransformedAst) => x

let transform_main = (ast :: DesugaredAst,
                      binder :: (TransformedAst) TransformedAst) =>
    let recFunc = recur
    let doList = (
        f :: (DesugaredAst, (TransformedAst) TransformedAst) TransformedAst,
        list :: [DesugaredAst],
        new :: [TransformedAst],
        b :: ([TransformedAst]) TransformedAst
    ) =>
        if list == [] then b(new) else
        let innerRec = recur
        f(list:0, (x :: TransformedAst) =>
                    innerRec(f, list:1..length(list), new + [x], b))

    let doObjList = (
        f :: (IdValuePair</DesugaredAst/>,
              (IdValuePair</TransformedAst/>) TransformedAst) TransformedAst,
        list :: [IdValuePair</DesugaredAst/>],
        new :: [IdValuePair</TransformedAst/>],
        b :: ([IdValuePair</TransformedAst/>]) TransformedAst
    ) =>
        if list == [] then b(new) else
        let innerRec = recur
        f(list:0, (x :: IdValuePair</TransformedAst/>) =>
                    innerRec(f, list:1..length(list), new + [x], b))

    switch ast <|
        DesugaredAst.array ->
            doList(recur,
                   that.contents,
                   [],
                   (x :: [TransformedAst]) => binder(TransformedAst.array(x))),
        DesugaredAst.assignment ->
            let body = recur(that.body, binder)
            recur(
                that.value,
                (x :: TransformedAst) => TransformedAst.assignment(
                    that.identifier,
                    x,
                    body
                )
            ),
        DesugaredAst.call ->
            recur(that.func, (func :: TransformedAst) => doList(
                recFunc,
                that.args,
                [],
                (args :: [TransformedAst]) =>
                    binder(TransformedAst.call(func, args))
            )),
        DesugaredAst.conditional ->
            let thn = recur(that.thn, binder)
            let els = recur(that.els, binder)
            recur(
                that.cond,
                (x :: TransformedAst) => TransformedAst.conditional(x, thn, els)
            ),
        DesugaredAst.field_access ->
            recur(that.obj, (x :: TransformedAst) => binder(
                TransformedAst.field_access(x, that.field)
            )),
        DesugaredAst.lambda ->
            binder(TransformedAst.lambda(that.params, recur(that.body, idfun))),
        DesugaredAst.lookup -> binder(TransformedAst.lookup(that.identifier)),
        DesugaredAst.number -> binder(TransformedAst.number(that.value)),
        DesugaredAst.object ->
            let f = (
                pair :: IdValuePair</DesugaredAst/>,
                b :: (IdValuePair</TransformedAst/>) TransformedAst
            ) => recFunc(
                pair.value,
                (x :: TransformedAst) =>
                    b(IdValuePair</TransformedAst/>(pair.identifier, x))
            )
            doObjList(f,
                      that.contents,
                      [],
                      (x :: [IdValuePair</TransformedAst/>]) =>
                          binder(TransformedAst.object(x)))
    |>

(program_as_string :: [Int64]) =>
    transform_main(uniqueIds(desugar(program_as_string)), idfun)
