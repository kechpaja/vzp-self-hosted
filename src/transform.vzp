import typecheck
import utils

let restOf = (x :: [Object]) => if x.length <= 1 then [] else x:1..(x.length-1)

/* Run through AST and add something to IDs to make them unique */
let uniqueIds = (astOuter :: Object) =>
    ((ast :: Object, env :: [Object], prefix :: [Int64]) =>
        let replaceIfInEnv = (id :: [Int64], e :: [Object]) =>
            if e == [] then id else 
            if (e:0).orig == id then (e:0).new else recur(id, restOf(e))
        let appendToEnv = (orig :: [Int64], new :: [Int64], e :: [Object]) =>
            [{ orig: orig, new: new }] + e

        let recFunc = recur
        let argRec = (args :: [Object]) =>
            if args.length == 0 then [] else
            ((x :: Int64) => 
                recFunc(args:(x-1),
                        env,
                        prefix + utils.itoa(x) + ".")) $ 1..args.length

        if ast.type == "array" then
            { type: "array",
              contents: argRec(ast.contents) }
        else if ast.type == "assignment" then
            let newId = prefix + ast.identifier
            { type: "assignment",
              identifier: newId,
              value: recur(ast.value, env, prefix + "0."),
              body: recur(ast.body,
                          appendToEnv(ast.identifier, newId, env),
                          prefix + "1.") }
        else if ast.type == "call" then
            { type: "call",
              func: recur(ast.func, env, prefix + "0."),
              args: argRec(ast.args) }
        else if ast.type == "conditional" then
            { type: "conditional",
              cond: recur(ast.cond, env, prefix + "0."),
              thn: recur(ast.thn, env, prefix + "1."),
              els: recur(ast.els, env, prefix + "2.") }
        else if ast.type == "field_access" then
            { type: "field_access",
              obj: recur(ast.obj, env, prefix + "0."),
              field: ast.field }
        else if ast.type == "lambda" then
            { type: "lambda",
              params: ast.params, /* TODO Replace these? */
              body: recur(ast.body, env, prefix + "0.") }
        else if ast.type == "lookup" then
            { type: "lookup",
              identifier: replaceIfInEnv(ast.identifier, env) }
        else if ast.type == "object" then
            let f = (contents :: [Object]) =>
                if contents.length == 0 then [] else
                let nums = 1..contents.length
                ((x :: Int64) => 
                    { identifier: (contents:(x-1)).identifier,
                      value: recFunc((contents:(x-1)).value,
                                     env,
                                     prefix + utils.itoa(x) + ".") }) $ nums 
            { type: "object",
              contents: f(ast.contents) }
        else
            ast)(astOuter, [], ".")

let transform_main = (ast :: Object) =>
    let anyAssnOrCondIn = (array :: [Object]) =>
        || @> (((x :: Object) => x.type == "assignment" 
                              || x.type == "conditional") $ array) false

    let argRec = (origArgs :: [Object],
                  newArgs :: [Object],
                  bottomFunc :: ([Object]) Object) =>
        if origArgs.length == 0 then
            bottomFunc(newArgs)
        else if (origArgs:0).type == "assignment" then
            { type: "assignment",
              identifier: (origArgs:0).identifier,
              value: (origArgs:0).value,
              body: recur(restOf(origArgs),
                          newArgs + [(origArgs:0).body],
                          bottomFunc) }
        else if (origArgs:0).type == "conditional" then
            { type: "conditional",
              cond: (origArgs:0).cond,
              thn: recur(restOf(origArgs),
                         newArgs + [(origArgs:0).thn],
                         bottomFunc),
              els: recur(restOf(origArgs),
                         newArgs + [(origArgs:0).els],
                         bottomFunc) }
        else
            recur(restOf(origArgs), newArgs + [origArgs:0], bottomFunc)

    if ast.type == "array" then
        if anyAssnOrCondIn(ast.contents) then
            recur(argRec(ast.contents, 
                         [],
                         (contents :: [Object]) => { type: "array",
                                                     contents: contents}))
        else
            { type: "array", contents: recur $ ast.contents }
    else if ast.type == "assignment" then
        if ast.value.type == "assignment" then
            let innerAssn = uniqueIds(ast.value)
            recur({ type: "assignment",
                    identifier: ast.value.identifier,
                    value: ast.value.value,
                    body: { type: "assignment",
                            identifier: ast.identifier,
                            value: ast.value.body,
                            body: ast.body } })
        else if ast.value.type == "conditional" then
            recur({ type: "conditional",
                    cond: ast.value.cond,
                    thn: { type: "assignment",
                           identifier: ast.identifier,
                           value: ast.value.thn,
                           body: ast.body },
                    els: { type: "assignment",
                           identifier: ast.identifier,
                           value: ast.value.els,
                           body: ast.body } })
        else if ast.value.type == "call" && anyAssnOrCondIn(ast.value.args) then
            recur({ type: "assignment",
                    identifier: ast.identifier,
                    value: argRec(ast.value.args, 
                                  [], 
                                  (args :: [Object]) => { type: "call",
                                                          func: ast.value.func,
                                                          args: args }),
                    body: ast.body })
        else
            { type: "js-assignment",
              identifier: ast.identifier,
              value: recur(ast.value),
              body: recur(ast.body) }
    else if ast.type == "call" then
        if ast.func.type == "assignment" then
            recur({ type: "assignment",
                    identifier: ast.func.identifier,
                    value: ast.func.value,
                    body: { type: "call",
                            func: ast.func.body,
                            args: ast.args } })
        else if ast.func.type == "conditional" then
            recur({ type: "conditional",
                    cond: ast.func.cond,
                    thn: { type: "call",
                           func: ast.func.thn,
                           args: ast.args },
                    els: { type: "call",
                           func: ast.func.els,
                           args: ast.args } })
        else if anyAssnOrCondIn(ast.args) then
            /* TODO This isn't good enough; got js-conditional in output */
            /* TODO Need to handle case where stuff gets lifted out when the
             * call is in a lettable position. */
            recur(argRec(ast.args, [], (args :: [Object]) => { type: "call",
                                                               func: ast.func,
                                                               args: args }))
        else
            { type: "call",
              func: recur(ast.func),
              args: recur $ ast.args }
    else if ast.type == "conditional" then
        if ast.cond.type == "assignment" then
            recur({ type: "assignment",
                    identifier: ast.cond.identifier,
                    value: ast.cond.value,
                    body: { type: "conditional",
                            cond: ast.cond.body,
                            thn: ast.thn,
                            els: ast.els } })
        else if ast.cond.type == "conditional" then
            recur({ type: "conditional",
                    cond: ast.cond.cond,
                    thn: { type: "conditional",
                           cond: ast.cond.thn,
                           thn: ast.thn,
                           els: ast.els },
                    els: { type: "conditional",
                           cond: ast.cond.els,
                           thn: ast.thn,
                           els: ast.els } })
        else if ast.cond.type == "call" && anyAssnOrCondIn(ast.cond.args) then
            recur({ type: "conditional",
                    cond: argRec(ast.cond.args, 
                                 [],
                                 (args :: [Object]) => { type: "call",
                                                         func: ast.cond.func,
                                                         args: args }),
                    thn: ast.thn,
                    els: ast.els })
        else
            { type: "js-conditional",
              cond: recur(ast.cond),
              thn: recur(ast.thn),
              els: recur(ast.els) }
    else if ast.type == "field_access" then
        if ast.obj.type == "assignment" then
            recur({ type: "assignment",
                    identifier: ast.obj.identifier,
                    value: ast.obj.value,
                    body: { type: "field_access",
                            obj: ast.obj.body,
                            field: ast.field } })
        else if ast.obj.type == "conditional" then
            recur({ type: "conditional",
                    cond: ast.obj.cond,
                    thn: { type: "field_access",
                           obj: ast.obj.thn,
                           field: ast.field },
                    els: { type: "field_access",
                           obj: ast.obj.els,
                           field: ast.field } })
        else
            { type: "field_access",
              obj: recur(ast.obj),
              field: ast.field }
    else if ast.type == "lambda" then
        { type: "lambda",
          params: ast.params,
          body: recur(ast.body) }
    else if ast.type == "object" then
        let values = ((x :: Object) => x.value) $ ast.contents
        if anyAssnOrCondIn(values) then
            let fields = ((x :: Object) => x.identifier) $ ast.contents
            recur(argRec(values, [], (values :: [Object]) => { 
                type: "object",
                contents: ((x :: Int64) => 
                               { identifier: fields:x,
                                 value: values:x }) $ 0..(fields.length-1)
            }))
        else
            let f = (let recFunc = recur; (x :: Object) => 
                                                 { identifier: x.identifier,
                                                   value: recFunc(x.value) })
            { type: "object",
              contents: (f $ ast.contents) }
    else
        ast

(program_as_string :: [Int64]) =>
    transform_main(uniqueIds(typecheck(program_as_string)))
