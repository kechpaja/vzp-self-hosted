import typecheck
import utils

let restOf = (x) => if x.length <= 1 then [] else x:1..(x.length-1)

/* Run through AST and add something to IDs to make them unique */
let uniqueIds = (astOuter) =>
    ((ast, env, prefix) =>
        let replaceIfInEnv = (id, e) =>
            if e == [] then id else 
            if (e:0).orig == id then (e:0).new else recur(id, restOf(e))
        let appendToEnv = (orig, new, e) => [{ orig: orig, new: new }] + e

        let recFunc = recur
        let argRec = (args) =>
            if args.length == 0 then [] else
            ((x) => recFunc(args:(x-1),
                            env,
                            prefix + utils.itoa(x) + ".")) $ 1..args.length

        if ast.type == "array" then
            { type: "array",
              contents: argRec(ast.contents) }
        else if ast.type == "assignment" then
            let newId = prefix + ast.identifier
            { type: "assignment",
              identifier: newId,
              value: recur(ast.value, env, prefix + "0."),
              body: recur(ast.body,
                          appendToEnv(ast.identifier, newId, env),
                          prefix + "1.") }
        else if ast.type == "call" then
            { type: "call",
              func: recur(ast.func, env, prefix + "0."),
              args: argRec(ast.args) }
        else if ast.type == "conditional" then
            { type: "conditional",
              cond: recur(ast.cond, env, prefix + "0."),
              thn: recur(ast.thn, env, prefix + "1."),
              els: recur(ast.els, env, prefix + "2.") }
        else if ast.type == "field_access" then
            { type: "field_access",
              obj: recur(ast.obj, env, prefix + "0."),
              field: ast.field }
        else if ast.type == "lambda" then
            { type: "lambda",
              params: ast.params, /* TODO Replace these? */
              body: recur(ast.body, env, prefix + "0.") }
        else if ast.type == "lookup" then
            { type: "lookup",
              identifier: replaceIfInEnv(ast.identifier, env) }
        else if ast.type == "object" then
            let f = (contents) =>
                if contents.length == 0 then [] else
                let nums = 1..contents.length
                ((x) => { identifier: (contents:(x-1)).identifier,
                          value: recFunc((contents:(x-1)).value,
                                         env,
                                         prefix + utils.itoa(x) + ".") }) $ nums 
            { type: "object",
              contents: f(ast.contents) }
        else
            ast)(astOuter, [], ".")

let wrapFunc = (x) =>
    if x.type == "assignment" || x.type == "js-conditional" then
        { type: "funcwrap", body: x }
    else
        x

let transform_main = (ast) =>
    let argRec = (origArgs, newArgs, bottomFunc) =>
        if origArgs.length == 0 then
            bottomFunc(newArgs)
        else if (origArgs:0).type == "assignment" then
            { type: "assignment",
              identifier: (origArgs:0).identifier,
              value: (origArgs:0).value,
              body: recur(restOf(origArgs),
                          newArgs + [(origArgs:0).body],
                          bottomFunc) }
        else if (origArgs:0).type == "conditional" then
            { type: "conditional",
              cond: (origArgs:0).cond,
              thn: recur(restOf(origArgs),
                         newArgs + [(origArgs:0).thn],
                         bottomFunc),
              els: recur(restOf(origArgs),
                         newArgs + [(origArgs:0).els],
                         bottomFunc) }
        else
            recur(restOf(origArgs), newArgs + origArgs:[0], bottomFunc)

    if ast.type == "array" then
        if || @> (((x) => x.type == "assignment" 
                       || x.type == "conditional") $ ast.contents) false then
            recur(argRec(ast.contents, [], (contents) => { type: "array",
                                                           contents: contents}))
        else
            { type: "array", contents: recur $ ast.contents }
    else if ast.type == "assignment" then
        if ast.value.type == "assignment" then
            let innerAssn = uniqueIds(ast.value)
            recur({ type: "assignment",
                    identifier: ast.value.identifier,
                    value: ast.value.value,
                    body: { type: "assignment",
                            identifier: ast.identifier,
                            value: ast.value.body,
                            body: ast.body } })
        else if ast.value.type == "conditional" then
            recur({ type: "conditional",
                    cond: ast.value.cond,
                    thn: { type: "assignment",
                           identifier: ast.identifier,
                           value: ast.value.thn,
                           body: ast.body },
                    els: { type: "assignment",
                           identifier: ast.identifier,
                           value: ast.value.els,
                           body: ast.body } })
        else
            { type: "assignment",
              identifier: ast.identifier,
              value: recur(ast.value),
              body: recur(ast.body) }
    else if ast.type == "call" then
        { type: "call",
          func: wrapFunc(recur(ast.func)),
          args: (wrapFunc $ (recur $ ast.args)) }
    else if ast.type == "conditional" then
        if ast.cond.type == "assignment" then
            recur({ type: "assignment",
                    identifier: ast.cond.identifier,
                    value: ast.cond.value,
                    body: { type: "conditional",
                            cond: ast.cond.body,
                            thn: ast.thn,
                            els: ast.els } })
        else if ast.cond.type == "conditional" then
            recur({ type: "conditional",
                    cond: ast.cond.cond,
                    thn: { type: "conditional",
                           cond: ast.cond.thn,
                           thn: ast.thn,
                           els: ast.els },
                    els: { type: "conditional",
                           cond: ast.cond.els,
                           thn: ast.thn,
                           els: ast.els } })
        else
            { type: "js-conditional",
              cond: recur(ast.cond),
              thn: recur(ast.thn),
              els: recur(ast.els) }
    else if ast.type == "field_access" then
        if ast.obj.type == "assignment" then
            recur({ type: "assignment",
                    identifier: ast.obj.identifier,
                    value: ast.obj.value,
                    body: { type: "field_access",
                            obj: ast.obj.body,
                            field: ast.field } })
        else if ast.obj.type == "conditional" then
            recur({ type: "conditional",
                    cond: ast.obj.cond,
                    thn: { type: "field_access",
                           obj: ast.obj.thn,
                           field: ast.field },
                    els: { type: "field_access",
                           obj: ast.obj.els,
                           field: ast.field } })
        else
            { type: "field_access",
              obj: recur(ast.obj),
              field: ast.field }
    else if ast.type == "lambda" then
        { type: "lambda",
          params: ast.params,
          body: recur(ast.body) }
    else if ast.type == "object" then
        let f = (let recFunc = recur; (x) => { identifier: x.identifier, 
                                              value: wrapFunc(recFunc(x.value))})
        { type: "object",
          contents: (f $ ast.contents) }
    else
        ast

(program_as_string) => transform_main(uniqueIds(typecheck(program_as_string)))
