import typecheck
import utils

let restOf = (x :: [Object]) => if x.length <= 1 then [] else x:1..(x.length-1)

/* Run through AST and add something to IDs to make them unique */
let uniqueIds = (astOuter :: Object) =>
    ((ast :: Object, env :: [Object], count :: Int64) =>
        let replaceIfInEnv = (id :: [Int64], e :: [Object]) =>
            if e == [] then id else 
            if (e:0).orig == id then (e:0).new else recur(id, restOf(e))
        let appendToEnv = (orig :: [Int64], new :: [Int64], e :: [Object]) =>
            [{ orig: orig, new: new }] + e

        let recFunc = recur
        let argRec = (args :: [Object], c :: Int64) =>
            let f = (x :: Object, saved :: Object) =>
                let arg = recFunc(x, env, saved.count)
                { ast: [arg.ast] + saved.ast, count: arg.count }
            f @> args { ast: [], count: c }

        if ast.type == "array" then
            let contents = argRec(ast.contents, count)
            { ast: { type: "array",
                     contents: contents.ast },
              count: contents.count }
        else if ast.type == "assignment" then
            let value = recur(ast.value, env, count + 1)
            let body = recur(ast.body,
                             appendToEnv(ast.identifier,
                                         "i" + utils.itoa(count),
                                         env),
                             value.count)
            { ast: { type: "assignment",
                     identifier: "i" + utils.itoa(count),
                     value: value.ast,
                     body: body.ast },
              count: body.count }
        else if ast.type == "call" then
            let func = recur(ast.func, env, count)
            let args = argRec(ast.args, func.count)
            { ast: { type: "call",
                     func: func.ast,
                     args: args.ast },
              count: args.count }
        else if ast.type == "conditional" then
            let cond = recur(ast.cond, env, count)
            let thn = recur(ast.thn, env, cond.count)
            let els = recur(ast.els, env, thn.count)
            { ast: { type: "conditional",
                     cond: cond.ast,
                     thn: thn.ast,
                     els: els.ast },
              count: els.count }
        else if ast.type == "field_access" then
            let obj = recur(ast.obj, env, count)
            { ast: { type: "field_access",
                     obj: obj.ast,
                     field: ast.field },
              count: obj.count }
        else if ast.type == "lambda" then
            let body = recur(ast.body, env, count)
            { ast: { type: "lambda",
                     params: ast.params, /* XXX Replace these? */
                     body: body.ast },
              count: body.count }
        else if ast.type == "lookup" then
            { ast: { type: "lookup",
                     identifier: replaceIfInEnv(ast.identifier, env) },
              count: count }
        else if ast.type == "object" then
            let f = (pair :: Object, saved :: Object) =>
                let newValue = recFunc(pair.value, env, saved.count)
                let newPair = { identifier: pair.identifier,
                                value: newValue.ast }
                { ast: [newPair] + saved.ast, count: newValue.count }

            let contents = f @> ast.contents { ast: [], count: count }
            { ast: { type: "object", contents: contents.ast },
              count: contents.count }
        else
            { ast: ast, count: count })(astOuter, [], 0).ast

let transform_main = (ast :: Object) =>
    let anyAssnOrCondIn = (array :: [Object]) =>
        || @> (((x :: Object) => x.type == "assignment" 
                              || x.type == "conditional") $ array) false

    let argRec = (origArgs :: [Object],
                  newArgs :: [Object],
                  bottomFunc :: ([Object]) Object) =>
        if origArgs.length == 0 then
            bottomFunc(newArgs)
        else if (origArgs:0).type == "assignment" then
            { type: "assignment",
              identifier: (origArgs:0).identifier,
              value: (origArgs:0).value,
              body: recur(restOf(origArgs),
                          newArgs + [(origArgs:0).body],
                          bottomFunc) }
        else if (origArgs:0).type == "conditional" then
            { type: "conditional",
              cond: (origArgs:0).cond,
              thn: recur(restOf(origArgs),
                         newArgs + [(origArgs:0).thn],
                         bottomFunc),
              els: recur(restOf(origArgs),
                         newArgs + [(origArgs:0).els],
                         bottomFunc) }
        else
            recur(restOf(origArgs), newArgs + [origArgs:0], bottomFunc)

    if ast.type == "array" then
        if anyAssnOrCondIn(ast.contents) then
            recur(argRec(ast.contents, 
                         [],
                         (contents :: [Object]) => { type: "array",
                                                     contents: contents}))
        else
            { type: "array", contents: recur $ ast.contents }
    else if ast.type == "assignment" then
        if ast.value.type == "assignment" then
            recur({ type: "assignment",
                    identifier: ast.value.identifier,
                    value: ast.value.value,
                    body: { type: "assignment",
                            identifier: ast.identifier,
                            value: ast.value.body,
                            body: ast.body } })
        else if ast.value.type == "conditional" then
            recur({ type: "conditional",
                    cond: ast.value.cond,
                    thn: { type: "assignment",
                           identifier: ast.identifier,
                           value: ast.value.thn,
                           body: ast.body },
                    els: { type: "assignment",
                           identifier: ast.identifier,
                           value: ast.value.els,
                           body: ast.body } })
        else if ast.value.type == "call" && anyAssnOrCondIn(ast.value.args) then
            recur({ type: "assignment",
                    identifier: ast.identifier,
                    value: argRec(ast.value.args, 
                                  [], 
                                  (args :: [Object]) => { type: "call",
                                                          func: ast.value.func,
                                                          args: args }),
                    body: ast.body })
        else
            { type: "js-assignment",
              identifier: ast.identifier,
              value: recur(ast.value),
              body: recur(ast.body) }
    else if ast.type == "call" then
        if ast.func.type == "assignment" then
            recur({ type: "assignment",
                    identifier: ast.func.identifier,
                    value: ast.func.value,
                    body: { type: "call",
                            func: ast.func.body,
                            args: ast.args } })
        else if ast.func.type == "conditional" then
            recur({ type: "conditional",
                    cond: ast.func.cond,
                    thn: { type: "call",
                           func: ast.func.thn,
                           args: ast.args },
                    els: { type: "call",
                           func: ast.func.els,
                           args: ast.args } })
        else if anyAssnOrCondIn(ast.args) then
            /* TODO This isn't good enough; got js-conditional in output */
            /* TODO Need to handle case where stuff gets lifted out when the
             * call is in a lettable position. */
            recur(argRec(ast.args, [], (args :: [Object]) => { type: "call",
                                                               func: ast.func,
                                                               args: args }))
        else
            { type: "call",
              func: recur(ast.func),
              args: recur $ ast.args }
    else if ast.type == "conditional" then
        if ast.cond.type == "assignment" then
            recur({ type: "assignment",
                    identifier: ast.cond.identifier,
                    value: ast.cond.value,
                    body: { type: "conditional",
                            cond: ast.cond.body,
                            thn: ast.thn,
                            els: ast.els } })
        else if ast.cond.type == "conditional" then
            recur({ type: "conditional",
                    cond: ast.cond.cond,
                    thn: { type: "conditional",
                           cond: ast.cond.thn,
                           thn: ast.thn,
                           els: ast.els },
                    els: { type: "conditional",
                           cond: ast.cond.els,
                           thn: ast.thn,
                           els: ast.els } })
        else if ast.cond.type == "call" && anyAssnOrCondIn(ast.cond.args) then
            recur({ type: "conditional",
                    cond: argRec(ast.cond.args, 
                                 [],
                                 (args :: [Object]) => { type: "call",
                                                         func: ast.cond.func,
                                                         args: args }),
                    thn: ast.thn,
                    els: ast.els })
        else
            { type: "js-conditional",
              cond: recur(ast.cond),
              thn: recur(ast.thn),
              els: recur(ast.els) }
    else if ast.type == "field_access" then
        if ast.obj.type == "assignment" then
            recur({ type: "assignment",
                    identifier: ast.obj.identifier,
                    value: ast.obj.value,
                    body: { type: "field_access",
                            obj: ast.obj.body,
                            field: ast.field } })
        else if ast.obj.type == "conditional" then
            recur({ type: "conditional",
                    cond: ast.obj.cond,
                    thn: { type: "field_access",
                           obj: ast.obj.thn,
                           field: ast.field },
                    els: { type: "field_access",
                           obj: ast.obj.els,
                           field: ast.field } })
        else
            { type: "field_access",
              obj: recur(ast.obj),
              field: ast.field }
    else if ast.type == "lambda" then
        { type: "lambda",
          params: ast.params,
          body: recur(ast.body) }
    else if ast.type == "object" then
        let values = ((x :: Object) => x.value) $ ast.contents
        if anyAssnOrCondIn(values) then
            let fields = ((x :: Object) => x.identifier) $ ast.contents
            recur(argRec(values, [], (values :: [Object]) => { 
                type: "object",
                contents: ((x :: Int64) => 
                               { identifier: fields:x,
                                 value: values:x }) $ 0..(fields.length-1)
            }))
        else
            let f = (let recFunc = recur; (x :: Object) => 
                                                 { identifier: x.identifier,
                                                   value: recFunc(x.value) })
            { type: "object",
              contents: (f $ ast.contents) }
    else
        ast

(program_as_string :: [Int64]) =>
    transform_main(uniqueIds(typecheck(program_as_string)))
