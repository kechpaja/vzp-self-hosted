import desugar
import utils

let restOf = (x :: [Object]) => if x.length <= 1 then [] else x:1..(x.length-1)

let ctoid = (x :: Int64) => "i" + utils.itoa(x)

/* Run through AST and add something to IDs to make them unique */
let uniqueIds = (astOuter :: Object) =>
    ((ast :: Object, env :: [Object], count :: Int64) =>
        let replaceIfInEnv = (id :: [Int64], e :: [Object]) =>
            if e == [] then id else 
            if (e:0).orig == id then (e:0).new else recur(id, restOf(e))
        let appendToEnv = (orig :: [Int64], new :: [Int64], e :: [Object]) =>
            [{ orig: orig, new: new }] + e

        let recFunc = recur
        let argRec = (args :: [Object], c :: Int64) =>
            let f = (x :: Object, saved :: Object) =>
                let arg = recFunc(x, env, saved.count)
                { ast: [arg.ast] + saved.ast, count: arg.count }
            f @> args { ast: [], count: c }

        if ast.type == "array" then
            let contents = argRec(ast.contents, count)
            { ast: { type: "array",
                     contents: contents.ast },
              count: contents.count }
        else if ast.type == "assignment" then
            let value = recur(ast.value, env, count + 1)
            let body = recur(ast.body,
                             appendToEnv(ast.identifier,
                                         ctoid(count),
                                         env),
                             value.count)
            { ast: { type: "assignment",
                     identifier: ctoid(count),
                     value: value.ast,
                     body: body.ast },
              count: body.count }
        else if ast.type == "call" then
            let func = recur(ast.func, env, count)
            let args = argRec(ast.args, func.count)
            { ast: { type: "call",
                     func: func.ast,
                     args: args.ast },
              count: args.count }
        else if ast.type == "conditional" then
            let cond = recur(ast.cond, env, count)
            let thn = recur(ast.thn, env, cond.count)
            let els = recur(ast.els, env, thn.count)
            { ast: { type: "conditional",
                     cond: cond.ast,
                     thn: thn.ast,
                     els: els.ast },
              count: els.count }
        else if ast.type == "field_access" then
            let obj = recur(ast.obj, env, count)
            { ast: { type: "field_access",
                     obj: obj.ast,
                     field: ast.field },
              count: obj.count }
        else if ast.type == "lambda" then
            let augmentEnv = (params :: [[Int64]], e :: [Object], c :: Int64) =>
                let ln = params.length
                if ln == 0 then e else
                if ln == 1 then appendToEnv(params:0, ctoid(c), e) else
                appendToEnv(params:0, ctoid(c), recur(params:1..(ln-1), e, c+1))

            let newEnv = augmentEnv(ast.params, env, count)
            let body = recur(ast.body, newEnv, count + ast.params.length)
            { ast: { type: "lambda",
                     params: ((x :: Int64) => 
                                  replaceIfInEnv(x, newEnv)) $ ast.params,
                     body: body.ast },
              count: body.count }
        else if ast.type == "lookup" then
            { ast: { type: "lookup",
                     identifier: replaceIfInEnv(ast.identifier, env) },
              count: count }
        else if ast.type == "object" then
            let f = (pair :: Object, saved :: Object) =>
                let newValue = recFunc(pair.value, env, saved.count)
                let newPair = { identifier: pair.identifier,
                                value: newValue.ast }
                { ast: [newPair] + saved.ast, count: newValue.count }

            let contents = f @> ast.contents { ast: [], count: count }
            { ast: { type: "object", contents: contents.ast },
              count: contents.count }
        else
            { ast: ast, count: count })(astOuter, [], 0).ast

let transform_main = (ast :: Object, binder :: (Object) Object) =>
    let recFunc = recur
    let doList = (f :: (Object, (Object) Object) Object,
                  list :: [Object],
                  new :: [Object],
                  b :: ([Object]) Object) =>
        if list == [] then b(new) else
        let innerRec = recur
        f(list:0, (x :: Object) => innerRec(f, restOf(list), new + [x], b))

    if ast.type == "array" then
        doList(recur, ast.contents, [], (x :: [Object]) => binder({ type: "array",
                                                             contents: x }))
    else if ast.type == "assignment" then
        let body = recur(ast.body, binder)
        recur(ast.value, (x :: Object) => { type: "js-assignment", 
                                            identifier: ast.identifier,
                                            value: x,
                                            body: body })
    else if ast.type == "call" then
        recur(ast.func, 
              (func :: Object) => doList(recFunc,
                                         ast.args,
                                         [],
                                         (args :: [Object]) => binder({ type: "call",
                                                                 func: func,
                                                                 args: args })))
    else if ast.type == "conditional" then
        let thn = recur(ast.thn, binder)
        let els = recur(ast.els, binder)
        recur(ast.cond, (x :: Object) => { type: "js-conditional",
                                           cond: x,
                                           thn: thn,
                                           els: els })
    else if ast.type == "field_access" then
        recur(ast.obj, (x :: Object) => binder({ type: "field_access", 
                                          obj: x,
                                          field: ast.field }))
    else if ast.type == "lambda" then
        binder({ type: "lambda", 
                 params: ast.params,
                 body: recur(ast.body, (x :: Object) => x) })
    else if ast.type == "object" then
        let f = (pair :: Object, b :: (Object) Object) =>
            recFunc(pair.value, 
                    (x :: Object) => b({ identifier: pair.identifier,
                                         value: x }))
        doList(f, ast.contents, [], (x :: Object) => binder({ type: "object",
                                                              contents: x }))
    else
        binder(ast)

(program_as_string :: [Int64]) =>
    transform_main(uniqueIds(desugar(program_as_string)), (x :: Object) => x)
