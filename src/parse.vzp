import tokenize
import ast
import utils

/* TODO this should be in a library somewhere */
let restOf = (array) =>
    if array.length < 2 then [] else array:(1..(array.length-1))

let opsByPrec = [ [ "||" ], /* Lowest to highest */
                  [ "&&" ],
                  [ "==", "!=" ],
                  [ ">", "<", ">=", "<=" ],
                  [ "+", "-" ],
                  [ "*", "/", "%" ],
                  [ "$", "@>", "<@" ],
                  [ ":"  ],
                  [ ".." ],
                  [ ".", "(" ] ]

let isDigit = (c) => c <= 57 && c >= 48

let isAlpha = (c) => (c <= 90 && c >= 65) || (c <= 122 && c >= 97) || c == 95

let isNumber = (string) => (((a, b) => a && b) <@ true isDigit $ string)

let isValidId = (string) => 
    (string.length > 0)
 && isAlpha(string:0)
 && ((x, y) => x && (isAlpha(y) || isDigit(y))) <@ true restOf(string)

let fail = (error) =>
    let unused = print(error)
    { wellFormed: false, error: error } /* TODO */

let checkFor = (tokens, value) =>
    if tokens.length == 0 then false else (tokens:0) == value

let noFollowingExpr = (tokens) =>
    tokens.length == 0
 || utils.in(tokens:0, [";", ")", "}", "]", "then", "else"]) /* TODO binops */

let parseParamList = (tokens) =>
    if (tokens.length == 0) || ((tokens:0) == ")") then [] else
    if (tokens.length >= 2) && isValidId(tokens:0) && ((tokens:1) == ")") then
        { ast: [tokens:0], rest: restOf(tokens), wellFormed: true }
    else
        if !checkFor(restOf(tokens), ",") then { wellFormed: false } else
        let laterParams = recur(restOf(restOf(tokens))) /* TODO catch bad IDs */
        if !laterParams.wellFormed then { wellFormed: false } else
        { ast: ([tokens:0] + laterParams.ast), 
          rest: laterParams.rest, 
          wellFormed: true }

let parseArgList = (tokens, mutualRecParse) =>
    let listEnds = (tkns) =>
        ((tkns:0) == "]") || ((tkns:0) == ")") || ((tkns:0) == "}")

    if tokens.length == 0 then fail("End of tokens in parseArgList")
    else if listEnds(tokens) then
        { ast: [], rest: tokens, wellFormed: true }
    else
        let elem = mutualRecParse(tokens)
        if !elem.wellFormed then fail("Bad expr in parseArgList") else
        if listEnds(elem.rest) then
            { ast: [elem.ast], rest: elem.rest, wellFormed: true}
        else if checkFor(elem.rest, ",") then
            let moreArgs = recur(restOf(elem.rest), mutualRecParse)
            if !moreArgs.wellFormed then fail(moreArgs.error) else
            { ast: ([elem.ast] + moreArgs.ast),
              rest: moreArgs.rest,
              wellFormed: true}
        else
            fail("Expected comma in parseArgList")

let parseObjectInternalList = (tokens, mutualRecParse) =>
    let listEnds = (tkns) =>
        ((tkns:0) == "]") || ((tkns:0) == ")") || ((tkns:0) == "}")

    if tokens.length < 4 then
        fail("Too few tokens in parseObjectInternalList")
    else if listEnds(tokens) then 
        { ast: [], rest: tokens, wellFormed: true }
    else if !isValidId(tokens:0) || (tokens:1) != ":" then
        fail("Need an ID followed by ':' in an object field")
    else
        let elem = mutualRecParse(tokens:(2..(tokens.length-1)))
        if !elem.wellFormed then fail(elem.error) else
        if listEnds(elem.rest) then
            { ast: [{ identifier: (tokens:0), value: elem.ast }],
              rest: elem.rest,
              wellFormed: true }
        else if checkFor(elem.rest, ",") then
            let more = recur(restOf(elem.rest), mutualRecParse)
            if !more.wellFormed then fail(more.error) else
            { ast: ([{ identifier: (tokens:0), value: elem.ast }] + more.ast),
              rest: more.rest,
              wellFormed: true }
        else
            fail("Expected comma in parseObjectInternalList")

let parseDotsAndCalls = (expr, tokens, mutualRecParse) =>
    if tokens.length > 0 && (tokens:0) == "." then
        if (tokens.length < 2) || (!isValidId(tokens:1)) then
            fail("Not a valid field lookup")
        else
            let next = { type: "field_access", obj: expr, field: (tokens:1) }
            recur(next, restOf(restOf(tokens)), mutualRecParse)
        /* TODO consider handling decimal numbers here? */
    else if tokens.length > 0 && (tokens:0) == "(" then
        let list = parseArgList(restOf(tokens), mutualRecParse)
        if !list.wellFormed || !checkFor(list.rest, ")") then
            fail("Issue parsing argument list in call")
        else
            let next = { type: "call", func: expr, args: list.ast }
            recur(next, restOf(list.rest), mutualRecParse)
    else
        { ast: expr, rest: tokens, wellFormed: true }

let parse = (operations, tokens) =>
    let recurWithFullOps = let rcr = recur; (tkns) => rcr(opsByPrec, tkns)

    if operations.length == 0 then
        if tokens.length == 0 then
            fail("End of tokens in parse")
        else if tokens:0 == "if" then
            let cond = recur(opsByPrec, restOf(tokens))
            if !cond.wellFormed || !checkFor(cond.rest, "then")
                then fail("Bad expr in condition of if") else
            let thn = recur(opsByPrec, restOf(cond.rest))
            if (!thn.wellFormed) || (!checkFor(thn.rest, "else"))
                then fail("Bad expr in consequent of if") else
            let els = recur(opsByPrec, restOf(thn.rest))
            if !els.wellFormed then fail(els.error) else
            { ast: { type: "conditional",
                     cond: cond.ast,
                     thn: thn.ast,
                     els: els.ast },
              rest: els.rest,
              wellFormed: true }
        else if tokens:0 == "let" then
            if tokens.length < 5 || !isValidId(tokens:1) || tokens:2 != "=" then
                fail("Malformed 'let' expression")
            else
                let value = recur(opsByPrec, tokens:(3..(tokens.length-1)))
                if !value.wellFormed then fail(value.error) else
                if !checkFor(value.rest, ";") then
                    fail("Missing semicolon or newline after value of 'let'")
                else
                    let body = recur(opsByPrec, restOf(value.rest))
                    if !body.wellFormed then fail(body.error) else
                    { ast: { type: "assignment",
                             identifier: (tokens:1),
                             value: value.ast,
                             body: body.ast },
                      rest: body.rest,
                      wellFormed: true }
        else if tokens:0 == "import" then
            /* TODO consider allowing a string as the value you import from? */
            if tokens.length < 4 || !isValidId(tokens:1) then
                fail("Malformed import statement")
            else
                if (tokens.length >= 6) && ((tokens:2) == "as")
                                        && isValidId(tokens:3) then
                    if !checkFor(tokens:(4..(tokens.length-1)), ";") then
                        fail("Missing semicolon or newline in import")
                    else
                        let body=recurWithFullOps(tokens:(5..(tokens.length-1)))
                        if !body.wellFormed then fail(body.error) else
                        { ast: { type: "assignment",
                                 identifier: (tokens:3),
                                 value: { type: "import", module: (tokens:1) },
                                 body: body.ast },
                          rest: body.rest,
                          wellFormed: true }
                else
                    if !checkFor(tokens:(2..(tokens.length-1)), ";") then
                        fail("Missing semicolon or newline in import")
                    else
                        let body=recurWithFullOps(tokens:(3..(tokens.length-1)))
                        if !body.wellFormed then fail(body.error) else
                        { ast: { type: "assignment",
                                 identifier: (tokens:1),
                                 value: { type: "import", module: (tokens:1) },
                                 body: body.ast },
                          rest: body.rest,
                          wellFormed: true }
        else if tokens:0 == "[" then
            let list = parseArgList(restOf(tokens), recurWithFullOps)
            if !list.wellFormed || ! checkFor(list.rest, "]") then
                fail("Problem with list contents or final ]")
            else
                { ast: { type: "array", contents: list.ast },
                  rest: restOf(list.rest),
                  wellFormed: true }
        else if tokens:0 == "{" then
            let list = parseObjectInternalList(restOf(tokens), recurWithFullOps)
            if !list.wellFormed || !checkFor(list.rest, "}") then
                fail("Problem with object contents or final }")
            else
                { ast: { type: "object", contents: list.ast },
                  rest: restOf(list.rest),
                  wellFormed: true }
        else if tokens:0 == "(" then
            if tokens.length >= 4 && ((tokens:1) == ")")
                                  && ((tokens:2) == "=>") then
                let body = recurWithFullOps(tokens:(3..(tokens.length-1)))
                if !body.wellFormed then fail(body.error) else
                { ast: { type: "lambda", params: [], body: body.ast },
                  rest: body.rest,
                  wellFormed: true }
            else if (tokens.length >= 4) && isValidId(tokens:1) 
                           && (((tokens:2) == ",")
                          || (((tokens:2) == ")") && ((tokens:3) == "=>"))) then
                let list = parseParamList(restOf(tokens))
                if !list.wellFormed || !checkFor(list.rest, ")") then
                    fail("Problem with param list contents or final )")
                else if !checkFor(restOf(list.rest), "=>") then
                    fail("Expected '=>' after param list of function")
                else
                    let body = recurWithFullOps(restOf(restOf(list.rest)))
                    if !body.wellFormed then fail(body.error) else
                    { ast: { type: "lambda", params: list.ast, body: body.ast },
                      rest: body.rest,
                      wellFormed: true }
            else
                let expr = recurWithFullOps(restOf(tokens))
                if !expr.wellFormed || !checkFor(expr.rest, ")") then
                    fail("Problem parsing parenthesized expression")
                else
                    { ast: expr.ast,
                      rest: restOf(expr.rest),
                      wellFormed: true }
        else if utils.in(tokens:0, ["!", "-"]) then
            /* TODO allow unop as identifier*/
            let expr = recur([ [ ".", "(" ] ], restOf(tokens))
            if !expr.wellFormed then fail(expr.error) else
            let thisOp = (if tokens:0 == "-" then "unary -" else tokens:0)
            { ast: { type: "call",
                     func: { type: "lookup", identifier: thisOp },
                     args: [ expr.ast ] },
              rest: expr.rest,
              wellFormed: true }
        else if isNumber(tokens:0) then
            { ast: { type: "number",
                     value: utils.atoi(tokens:0) },
              rest: restOf(tokens),
              wellFormed: true }
        else if (tokens:0).length >= 2 && ((tokens:0):0)==34 
                                && ((tokens:0):((tokens:0).length-1)==34) then
            if (tokens:0).length == 2 then 
                { ast: { type: "array", contents: [] },
                  rest: restOf(tokens),
                  wellFormed: true }
            else
                let str = (tokens:0):(1..((tokens:0).length-2))
                { ast: { type: "array",
                         contents: ((x) => {type: "number", value: x}) $ str },
                  rest: restOf(tokens),
                  wellFormed: true }
        else if isValidId(tokens:0) || utils.in(tokens:0, + <@ [] opsByPrec)then
            { ast: { type: "lookup",
                     identifier: tokens:0 },
              rest: restOf(tokens),
              wellFormed: true }
        else
            fail("There's something wrong with this token: " + (tokens:0) + ":")
    else
        let left = recur(restOf(operations), tokens)
        if !left.wellFormed then fail(left.error) else
        if left.rest.length == 0 || !utils.in(left.rest:0, operations:0) then
            left
        else if utils.in(left.rest:0, [".", "("]) then
            parseDotsAndCalls(left.ast, left.rest, recurWithFullOps)
        else
            let right = recur(operations, restOf(left.rest))
            if !right.wellFormed then fail(right.error) else
            if !utils.in(left.rest:0, ["<@", "@>"]) then
                { ast: { type: "call",
                         func: { type: "lookup", identifier: left.rest:0 },
                         args: [ left.ast, right.ast ] },
                  rest: right.rest,
                  wellFormed: true }
            else
                /* TODO This is where we check for a comma if we put that in */
                let third = recur(operations, right.rest)
                if !third.wellFormed then fail(third.error) else
                { ast: { type: "call",
                         func: { type: "lookup", identifier: left.rest:0 },
                         args: [ left.ast, right.ast, third.ast ] },
                  rest: third.rest,
                  wellFormed: true }

/* Export a nice function that the typechecker can call */
(program_as_string) => parse(opsByPrec, tokenize(program_as_string))
