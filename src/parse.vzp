import tokenize
import utils

/* TODO this should be in a library somewhere */
let restOf = (array) =>
    if array.length < 2 then [] else array:(1..(array.length-1))

let opsByPrec = [ [ ".." ], /* Highest first */
                  [ ":"  ],
                  [ "$", "@>", "<@" ],
                  [ "*", "/", "%" ],
                  [ "+", "-" ],
                  [ ">", "<", ">=", "<=" ],
                  [ "==", "!=" ],
                  [ "&&" ],
                  [ "||" ] ]

let isDigit = (c) => c <= 57 && c >= 48

let isNumber = (string) => (((a, b) => a && b) <@ true isDigit $ string)

let fail = (error) =>
    let unused = print(error)
    { wellFormed: false, error: error } /* TODO */

let checkFor = (tokens, value) =>
    if tokens.length == 0 then false else (tokens:0) == value

let parseArgList = (tokens, mutualRecParse) =>
    let listEnds = () =>
        tokens:0 == "]" || tokens:0 == ")" || tokens:0 == "}"

    if tokens.length == 0 then fail("End of tokens in parseArgList")
    else if listEnds() then
        { ast: [], rest: restOf(tokens), wellFormed: true }
    else
        let elem = mutualRecParse(tokens)
        if !elem.wellFormed then fail("Bad expr in parseArgList") else
        if listEnds() then { ast: [elem.ast], rest: elem.rest, wellFormed: true}
        else if checkFor(elem.rest, ",") then
            let moreArgs = recur(restOf(elem.rest), mutualRecParse)
            { ast: [elem.ast] + moreArgs.ast,
              rest: moreArgs.rest,
              wellFormed: true}
        else
            fail("Expected comma in parseArgList")

let parse = (operations, tokens) =>
    if operations.length == 0 then
        if tokens.length == 0 then
            fail("End of tokens in parse")
        else if tokens:0 == "if" then
            let cond = recur(opsByPrec, restOf(tokens))
            if !cond.wellFormed || !checkFor(cond.rest, "then")
                then fail("Bad expr in condition of if") else
            let thn = recur(opsByPrec, restOf(cond.rest))
            if !thn.wellFormed || !checkFor(thn.rest, "else")
                then fail("Bad expr in consequent of if") else
            let els = recur(opsByPrec, restOf(thn.rest))
            { ast: { type: "conditional",
                     cond: cond.ast,
                     thn: thn.ast,
                     els: els.ast },
              rest: els.rest,
              wellFormed: true }
        else if tokens:0 == "[" then
            let list = parseArgList(restOf(tokens),
                                    (tkns) => recur(opsByPrec, tkns))
            if !list.wellFormed || ! checkFor(list.rest, "]") 
                then fail("Problem with list contents or final ]") else
            { ast: { type: "array",
                     contents: list.ast },
              rest: restOf(list.rest),
              wellFormed: true }
        else if isNumber(tokens:0) then
            { ast: { type: "number",
                     value: tokens:0 },
              rest: restOf(tokens),
              wellFormed: true }
        else
            { ast: { type: "lookup",
                     identifier: tokens:0 },
              rest: restOf(tokens),
              wellFormed: true }
            /* TODO lookups, objects, lambdas, parens */
    else
        let left = recur(restOf(operations), tokens)
        if left.rest.length == 0 then
            left
        else if left.rest:0 == "||" then /* TODO in list, not eq */
            let right = recur(operations, restOf(left.rest))
            { ast: { type: "call",
                     func: { type: "lookup", identifier: "||" },
                     args: [ left.ast, right.ast ] },
              rest: right.rest,
              wellFormed: true }
        else
            left /*TODO can merge with earlier case once we have short circuit*/

/* Export a nice function that the typechecker can call */
(program_as_string) => parse(opsByPrec, tokenize(program_as_string))
