import ast
import tokenize
import utils

/* TODO this should be in a library somewhere */
let restOf = (array :: [[Int64]]) =>
    if length(array) < 2 then [] else array:(1..length(array))

let restOfOps = (array :: [[[Int64]]]) =>
    if length(array) < 2 then [] else array:(1..length(array))

let restOfString = (array :: [Int64]) =>
    if length(array) < 2 then [] else array:(1..length(array))

let opsByPrec = [ [ "||" ], /* Lowest to highest */
                  [ "&&" ],
                  [ "==", "!=" ],
                  [ ">", "<", ">=", "<=" ],
                  [ "+", "-", "++" ],
                  [ "*", "/", "%"  ],
                  [ "^"  ],
                  [ "$", "@"],
                  [ ":"  ],
                  [ ".." ],
                  [ ".", "(", "~", "</" ] ]

let isDigit = (c :: Int64) => c <= 57 && c >= 48

let isAlpha = (c :: Int64) => (c <= 90 && c >= 65) || (c <= 122 && c >= 97)
                                                   || c == 95

let isNumber = (string :: [Int64]) => isDigit $ string ^ true @ (&&)

let isValidId = (string :: [Int64]) => 
    (length(string) > 0)
 && isAlpha(string:0)
 && restOfString(string) ^ true @ (x :: Boolean, y :: Int64) =>
                                        x && (isAlpha(y) || isDigit(y))

let fail = (error :: [Int64]) =>
    let unused = print(error)
    { wellFormed: false, error: error } /* TODO */

let checkFor = (tokens :: [[Int64]], value :: [Int64]) =>
    if length(tokens) == 0 then false else (tokens:0) == value

let noFollowingExpr = (tokens :: [[Int64]]) =>
    length(tokens) == 0
 || utils.in(tokens:0, [";", ")", "}", "]", "then", "else"]) /* TODO binops */

let parseTypeAnn = (tokens :: [[Int64]]) =>
    let recFunc = recur
    let parseTypeAnnList = (tokens :: [[Int64]]) =>
        if checkFor(tokens, ")") || checkFor(tokens, "]") 
                                 || checkFor(tokens, "/>") then
            { ann: [], rest: tokens, wellFormed: true }
        else
            let ann = recFunc(tokens)
            if !ann.wellFormed then { wellFormed: false } else
            if checkFor(ann.rest, ",") || checkFor(ann.rest, ")") 
                                       || checkFor(ann.rest, "]")
                                       || checkFor(ann.rest, "/>") then
                let recurOn = if ann.rest:0 == "," then restOf(ann.rest)
                                                   else ann.rest
                let laterAnns = recur(recurOn)
                if !laterAnns.wellFormed then { wellFormed: false } else
                { ann: [ann.ann] + laterAnns.ann,
                  rest: laterAnns.rest,
                  wellFormed: true }
            else
                { wellFormed: false }

    /* TODO this will get longer when we add objects, hashes, sets (tuples?) */
    if length(tokens) < 1 then { wellFormed: false } else
    if isValidId(tokens:0) then 
        if length(tokens) > 1 && checkFor(restOf(tokens), "</") then
            let innards = parseTypeAnnList(restOf(restOf(tokens)))
            if !innards.wellFormed || !checkFor(innards.rest, "/>") then
                { wellFormed: false }
            else
                { ann: { category: "named",
                         name: tokens:0,
                         args: innards.ann },
                  rest: restOf(innards.rest),
                  wellFormed: true }
        else
            { ann: { category: "named",
                     name: tokens:0,
                     args: [] },
              rest: restOf(tokens), 
              wellFormed: true }
    else if checkFor(tokens, "(") then
        let list = parseTypeAnnList(restOf(tokens))
        if !list.wellFormed || length(list.rest) < 1 || !checkFor(list.rest, ")")
            then { wellFormed: false }
            else
                let retType = recur(restOf(list.rest))
                if !retType.wellFormed then { wellFormed: false } else
                { ann: { category: "function",
                         return: retType.ann,
                         params: list.ann },
                  rest: retType.rest,
                  wellFormed: true }
    else if checkFor(tokens, "[") then
        let inner = recur(restOf(tokens))
        if !inner.wellFormed || length(inner.rest) < 1 
                             || !checkFor(inner.rest, "]")
            then { wellFormed: false }
            else { ann: { category: "array", contents: inner.ann },
                   rest: restOf(inner.rest),
                   wellFormed: true }
    else
        { wellFormed: false }

let parseParam = (tokens :: [[Int64]]) =>
    if length(tokens) < 3 || !isValidId(tokens:0) || tokens:1 != "::" then
        { wellFormed: false }
    else
        let ann = parseTypeAnn(restOf(restOf(tokens)))
        if !ann.wellFormed then { wellFormed: false } else
        { param: tokens:0, 
          ann: ann.ann,
          rest: ann.rest,
          wellFormed: true }

let parseParamList = (tokens :: [[Int64]]) =>
    if (length(tokens) == 0) || ((tokens:0) == ")") || ((tokens:0) == "}") then
        { ast: [], rest: tokens, wellFormed: true }
    else
        let param = parseParam(tokens)
        if !param.wellFormed then { wellFormed: false } else
        if checkFor(param.rest, ",") || checkFor(param.rest, ")")
                                     || checkFor(param.rest, "}") then
            let recurOn = if utils.in(param.rest:0, [")", "}"]) 
                          then param.rest
                          else restOf(param.rest)
            let laterParams = recur(recurOn)
            if !laterParams.wellFormed then { wellFormed: false } else
            { ast: [ { param: param.param, ann: param.ann } ] + laterParams.ast,
              rest: laterParams.rest,
              wellFormed: true }
        else
            { wellFormed: false }

let parseArgList = (tokens :: [[Int64]], mutualRecParse :: ([[Int64]]) Object)=>
    let listEnds = (tkns :: [[Int64]]) =>
        ((tkns:0) == "]") || ((tkns:0) == ")") || ((tkns:0) == "}")

    if length(tokens) == 0 then fail("End of tokens in parseArgList")
    else if listEnds(tokens) then
        { ast: [], rest: tokens, wellFormed: true }
    else
        let elem = mutualRecParse(tokens)
        if !elem.wellFormed then fail("Bad expr in parseArgList") else
        if listEnds(elem.rest) then
            { ast: [elem.ast], rest: elem.rest, wellFormed: true}
        else if checkFor(elem.rest, ",") then
            let moreArgs = recur(restOf(elem.rest), mutualRecParse)
            if !moreArgs.wellFormed then fail(moreArgs.error) else
            { ast: ([elem.ast] + moreArgs.ast),
              rest: moreArgs.rest,
              wellFormed: true}
        else
            fail("Expected comma in parseArgList")

let parseObjectInternalList = (tokens :: [[Int64]],
                               mutualRecParse :: ([[Int64]]) Object) =>
    let listEnds = (tkns :: [[Int64]]) =>
        ((tkns:0) == "]") || ((tkns:0) == ")") || ((tkns:0) == "}")

    if length(tokens) < 4 then
        fail("Too few tokens in parseObjectInternalList")
    else if listEnds(tokens) then 
        { ast: [], rest: tokens, wellFormed: true }
    else if !isValidId(tokens:0) || (tokens:1) != ":" then
        fail("Need an ID followed by ':' in an object field")
    else
        let elem = mutualRecParse(tokens:(2..length(tokens)))
        if !elem.wellFormed then fail(elem.error) else
        if listEnds(elem.rest) then
            { ast: [{ identifier: (tokens:0), value: elem.ast }],
              rest: elem.rest,
              wellFormed: true }
        else if checkFor(elem.rest, ",") then
            let more = recur(restOf(elem.rest), mutualRecParse)
            if !more.wellFormed then fail(more.error) else
            { ast: ([{ identifier: (tokens:0), value: elem.ast }] + more.ast),
              rest: more.rest,
              wellFormed: true }
        else
            fail("Expected comma in parseObjectInternalList")

let parseDotsAndCalls = (expr :: Object,
                         tokens :: [[Int64]],
                         mutualRecParse :: ([[[Int64]]], [[Int64]]) Object) =>
    let defaultCase = { ast: expr, rest: tokens, wellFormed: true }
    if length(tokens) > 0 && (tokens:0) == "." then
        if (length(tokens) < 2) || (!isValidId(tokens:1)) then
            fail("Not a valid field lookup")
        else
            let next = { type: "field_access", obj: expr, field: (tokens:1) }
            recur(next, restOf(restOf(tokens)), mutualRecParse)
        /* TODO consider handling decimal numbers here? */
    else if length(tokens) > 0 && (tokens:0) == "(" then
        let list = parseArgList(
            restOf(tokens),
            (x :: [[Int64]]) => mutualRecParse(opsByPrec, x)
        )
        if !list.wellFormed || !checkFor(list.rest, ")") then
            fail("Issue parsing argument list in call")
        else
            let next = { type: "call", func: expr, args: list.ast }
            recur(next, restOf(list.rest), mutualRecParse)
    else if length(tokens) > 0 && (tokens:0) == "~" then
        let otherArg = mutualRecParse([], restOf(tokens))
        let next = { type: "call",
                     func: { type: "lookup", identifier: "~" },
                     args: [expr, otherArg.ast] }
        recur(next, otherArg.rest, mutualRecParse)
    else if length(tokens) > 0 && (tokens:0) == "</" then
        let results = ((tkns :: [[Int64]]) =>
            if length(tkns) > 0 && tkns:0 == "/>" then
                { ast: [], rest: restOf(tkns), wellFormed: true }
            else
                let ann = parseTypeAnn(tkns)
                if !ann.wellFormed then fail("") else
                if checkFor(ann.rest, ",") then
                    let recurred = recur(restOf(ann.rest))
                    if recurred.wellFormed then
                        { ast: [ann.ann] + recurred.ast,
                          rest: recurred.rest,
                          wellFormed: true }
                    else fail("")
                else if checkFor(ann.rest, "/>") then
                    { ast: [ann.ann], rest: restOf(ann.rest), wellFormed: true }
                else fail("")
        )(restOf(tokens))
        if !results.wellFormed then defaultCase else
        let next = { type: "parametrized", expr: expr, types: results.ast }
        recur(next, results.rest, mutualRecParse)
    else
        defaultCase

let parseTypeDef = (tokens :: [[Int64]]) =>
    let recFunc = recur
    let handleStatics = (tkns :: [[Int64]]) =>
        if length(tkns) == 0 then
            fail("Problem parsing statics list")
        else if tkns:0 == "|>" then
            { ast: [], rest: restOf(tkns), wellFormed: true }
        else if isValidId(tkns:0) then
            let innerType = recFunc(restOf(tkns))
            if !innerType.wellFormed then fail("Statics list") else
            if innerType.rest:0 == "|>" then
                { ast: [{ identifier: tkns:0, value: innerType.ast }],
                  rest: restOf(innerType.rest),
                  wellFormed: true }
            else if innerType.rest:0 == "," then
                let restOfList = recur(restOf(innerType.rest))
                if !restOfList.wellFormed then fail("Statics list") else
                { ast: [{ identifier: tkns:0, 
                          value: innerType.ast }] + restOfList.ast,
                  rest: restOfList.rest,
                  wellFormed: true }
            else
                fail("Reached end of statics list but no |>!")
        else
            fail("Some problem parsing statics list: " + tkns:0)

    let handleParams = (tkns :: [[Int64]]) =>
        if length(tkns) == 0 then
            fail("Problem parsing type params list")
        else if tkns:0 == "/>" then
            { ast: [], rest: restOf(tkns), wellFormed: true }
        else if isValidId(tkns:0) then
            if checkFor(restOf(tkns), ",") then
                let remaining = recur(restOf(restOf(tkns)))
                if !remaining.wellFormed then fail("Type params list") else
                { ast: [tkns:0] + remaining.ast,
                  rest: remaining.rest,
                  wellFormed: true }
            else if checkFor(restOf(tkns), "/>") then
                { ast: [tkns:0], rest: restOf(restOf(tkns)), wellFormed: true }
            else
                fail("Reached end of type params list but no '/>'!")
        else
            fail("Some problem parsing type params list")

    if tokens:0 == "</" then
        let params = handleParams(restOf(tokens))
        if !params.wellFormed then fail(params.error) else
        if checkFor(params.rest, "{") then
            let fields = parseParamList(restOf(params.rest))
            if !fields.wellFormed then fail("Error in param'ed type fields")
            else if !checkFor(fields.rest, "}") then
                fail("Missing '}' in type definition")
            else if !checkFor(restOf(fields.rest), "<|") then
                { ast: { type: "type",
                         fields: fields.ast,
                         statics: [],
                         params: params.ast },
                  rest: restOf(fields.rest),
                  wellFormed: true }
            else
                let statics = handleStatics(restOf(restOf(fields.rest)))
                if !statics.wellFormed then fail("Error parsing type statics")
                else
                    { ast: { type: "type",
                             fields: fields.ast,
                             statics: statics.ast,
                             params: params.ast },
                      rest: statics.rest,
                      wellFormed: true }
        else if !checkFor(params.rest, "<|") then
            { ast: { type: "type",
                     fields: [],
                     statics: [],
                     params: params.ast },
              rest: params.rest,
              wellFormed: true }
        else
            let statics = handleStatics(restOf(params.rest))
            if !statics.wellFormed then fail("Error parsing type statics") else
            { ast: { type: "type",
                     fields: [],
                     statics: statics.ast,
                     params: params.ast },
              rest: statics.rest,
              wellFormed: true }
    else if tokens:0 == "{" then
        let fields = parseParamList(restOf(tokens))
        if !fields.wellFormed then fail("Error in unparam'ed type fields")
        else if !checkFor(fields.rest, "}") then
            fail("Missing '}' in type definition")
        else if !checkFor(restOf(fields.rest), "<|") then
            { ast: { type: "type",
                     fields: fields.ast,
                     statics: [],
                     params: [] },
              rest: restOf(fields.rest),
              wellFormed: true }
        else
            let statics = handleStatics(restOf(restOf(fields.rest)))
            if !statics.wellFormed then fail("Error parsing type statics") else
            { ast: { type: "type",
                     fields: fields.ast,
                     statics: statics.ast,
                     params: [] },
              rest: statics.rest,
              wellFormed: true }
    else if tokens:0 == "<|" then
        let statics = handleStatics(restOf(tokens))
        if !statics.wellFormed then fail("Error parsing type statics") else
        { ast: { type: "type",
                 fields: [],
                 statics: statics.ast,
                 params: [] },
          rest: statics.rest,
          wellFormed: true }
    else
        { ast: { type: "type", /* We do allow a type with no fields */
                 fields: [],
                 statics: [],
                 params: [] },
          rest: tokens,
          wellFormed: true }

let parseMap = (tokens :: [[Int64]],
                parseExpr :: ([[[Int64]]], [[Int64]]) Object) =>
    let left = parseExpr(opsByPrec, tokens)
    if !left.wellFormed then fail("parseMap: " + left.error) else
    if !checkFor(left.rest, "->") then fail("No -> in map!") else
    let right = parseExpr(opsByPrec, restOf(left.rest))
    if checkFor(right.rest, ",") then
        let rec = recur(restOf(right.rest), parseExpr)
        if !rec.wellFormed then fail(rec.error) else
        { ast: [{ left: left.ast, right: right.ast}] + rec.ast,
          rest: rec.rest,
          wellFormed: true } 
    else
        { ast: [{ left: left.ast, right: right.ast}],
          rest: right.rest,
          wellFormed: true }

let parseSwitch = (tokens :: [[Int64]],
                   parseExpr :: ([[[Int64]]], [[Int64]]) Object) =>
    /* switch <expr> <| <case> -> <another expr>, ... |> */
    let expr = parseExpr(opsByPrec, tokens)
    if !expr.wellFormed then fail("parseSwitch: " + expr.error) else
    if !checkFor(expr.rest, "<|") then fail("No <| in switch statement") else
    let cases = parseMap(restOf(expr.rest), parseExpr)
    if !cases.wellFormed then fail("parseSwitch: " + cases.error) else
    if !checkFor(cases.rest, "|>") then fail("No |> in switch statement") else
    { ast: { type: "switch",
             expr: expr.ast,
             cases: cases.ast },
      rest: restOf(cases.rest),
      wellFormed: true }

let parse = (operations :: [[[Int64]]], tokens :: [[Int64]]) =>
    let recurWithFullOps = let rcr = recur; (tkns :: [[Int64]]) => 
                                                        rcr(opsByPrec, tkns)

    if length(operations) == 0 then
        if length(tokens) == 0 then
            fail("End of tokens in parse")
        else if tokens:0 == "type" then
            parseTypeDef(restOf(tokens))
        else if tokens:0 == "switch" then
            parseSwitch(restOf(tokens), recur)
        else if tokens:0 == "if" then
            let cond = recur(opsByPrec, restOf(tokens))
            if !cond.wellFormed || !checkFor(cond.rest, "then")
                then fail("Bad expr in condition of if") else
            let thn = recur(opsByPrec, restOf(cond.rest))
            if (!thn.wellFormed) || (!checkFor(thn.rest, "else"))
                then fail("Bad expr in consequent of if") else
            let els = recur(opsByPrec, restOf(thn.rest))
            if !els.wellFormed then fail(els.error) else
            { ast: { type: "conditional",
                     cond: cond.ast,
                     thn: thn.ast,
                     els: els.ast },
              rest: els.rest,
              wellFormed: true }
        else if tokens:0 == "let" then
            if length(tokens) < 5 || !isValidId(tokens:1) || tokens:2 != "=" then
                fail("Malformed 'let' expression")
            else
                let value = recur(opsByPrec, tokens:(3..length(tokens)))
                if !value.wellFormed then fail(value.error) else
                if !checkFor(value.rest, ";") then
                    fail("Missing semicolon or newline after value of 'let',"
                         + " got '" + value.rest:0 + "' instead.")
                else
                    let body = recur(opsByPrec, restOf(value.rest))
                    if !body.wellFormed then fail(body.error) else
                    { ast: { type: "assignment",
                             identifier: (tokens:1),
                             value: value.ast,
                             body: body.ast },
                      rest: body.rest,
                      wellFormed: true }
        else if tokens:0 == "[" then
            let list = parseArgList(restOf(tokens), recurWithFullOps)
            if !list.wellFormed || ! checkFor(list.rest, "]") then
                fail("Problem with list contents or final ]")
            else
                { ast: { type: "array", contents: list.ast },
                  rest: restOf(list.rest),
                  wellFormed: true }
        else if tokens:0 == "{" then
            let list = parseObjectInternalList(restOf(tokens), recurWithFullOps)
            if !list.wellFormed || !checkFor(list.rest, "}") then
                fail("Problem with object contents or final }")
            else
                { ast: { type: "object", contents: list.ast },
                  rest: restOf(list.rest),
                  wellFormed: true }
        else if tokens:0 == "(" then
            if length(tokens) >= 4 && ((tokens:1) == ")")
                                  && ((tokens:2) == "=>") then
                let body = recurWithFullOps(tokens:(3..length(tokens)))
                if !body.wellFormed then fail(body.error) else
                { ast: { type: "lambda",
                         params: [],
                         returnType: { category: "dummy", name: "narrowest" },
                         body: body.ast },
                  rest: body.rest,
                  wellFormed: true }
            else if (length(tokens) >= 4) && isValidId(tokens:1) 
                           &&(tokens:2) == "::" then
                        /* TODO change here if we make annotation optional */
                let list = parseParamList(restOf(tokens))
                if !list.wellFormed then
                    fail("Problem with param list contents")
                else if !checkFor(list.rest, ")") then
                    fail("Problem with param list final )")
                else if !checkFor(restOf(list.rest), "=>") then
                    if checkFor(restOf(list.rest), "::") then
                        let returnType = parseTypeAnn(restOf(restOf(list.rest)))
                        if !returnType.wellFormed then
                            fail("Bad return type in function")
                        else if checkFor(returnType.rest, "=>") then
                            let body = recurWithFullOps(restOf(returnType.rest))
                            { ast: { type: "lambda",
                                     params: list.ast,
                                     body: body.ast,
                                     returnType: returnType.ann },
                              rest: body.rest,
                              wellFormed: true }
                        else fail("Expected '=>' after return type annotation")
                    else
                        fail("Expected '=>' or '::' after params of function")
                else
                    let body = recurWithFullOps(restOf(restOf(list.rest)))
                    if !body.wellFormed then fail(body.error) else
                    { ast: { type: "lambda",
                             params: list.ast,
                             body: body.ast,
                             returnType: { category: "dummy", name: "narrowest" } },
                      rest: body.rest,
                      wellFormed: true }
            else
                let expr = recurWithFullOps(restOf(tokens))
                if !expr.wellFormed || !checkFor(expr.rest, ")") then
                    fail("Problem parsing parenthesized expression")
                else
                    { ast: expr.ast,
                      rest: restOf(expr.rest),
                      wellFormed: true }
        else if utils.in(tokens:0, ["!", "-"]) then
            /* TODO allow unop as identifier*/
            let expr = recur([ [ ".", "(" ] ], restOf(tokens))
            if !expr.wellFormed then fail(expr.error) else
            let thisOp = (if tokens:0 == "-" then "unary -" else tokens:0)
            { ast: { type: "call",
                     func: { type: "lookup", identifier: thisOp },
                     args: [ expr.ast ] },
              rest: expr.rest,
              wellFormed: true }
        else if isNumber(tokens:0) then
            { ast: { type: "number",
                     value: utils.atoi(tokens:0) },
              rest: restOf(tokens),
              wellFormed: true }
        else if length(tokens:0) >= 2 && ((tokens:0):0)==34 
                                && ((tokens:0):(length(tokens:0)-1)==34) then
            if length(tokens:0) == 2 then 
                { ast: { type: "array", contents: [] },
                  rest: restOf(tokens),
                  wellFormed: true }
            else
                let str = (tokens:0):1..(length(tokens:0)-1)
                { ast: { type: "array",
                         contents: ((x :: Int64) =>
                                        {type: "number", value: x}) $ str },
                  rest: restOf(tokens),
                  wellFormed: true }
        else if isValidId(tokens:0) || utils.in(
                    tokens:0, 
                    opsByPrec ^ [] @ (a :: [[Int64]], b :: [[Int64]]) => a + b
                ) then
            { ast: { type: "lookup",
                     identifier: tokens:0 },
              rest: restOf(tokens),
              wellFormed: true }
        else
            fail("Invalid token '" + (tokens:0) + "' before '"
               + (if length(tokens) > 1 then tokens:1 else "") + "'")
    else
        let left = recur(restOfOps(operations), tokens)
        if !left.wellFormed then fail(left.error) else
        if length(left.rest) == 0 || !utils.in(left.rest:0, operations:0) then
            left
        else if utils.in(left.rest:0, [".", "(", "~", "</"]) then
            parseDotsAndCalls(left.ast, left.rest, recur)
        else
            let right = recur(operations, restOf(left.rest))
            if !right.wellFormed then fail(right.error) else
            { ast: { type: "call",
                     func: { type: "lookup", identifier: left.rest:0 },
                     args: [ left.ast, right.ast ] },
              rest: right.rest,
              wellFormed: true }

let parseWithImports = (tokens :: [[Int64]]) =>
    if tokens:0 == "import" then
        /* TODO consider allowing a string as the value you import from? */
        if length(tokens) < 4 || !isValidId(tokens:1) then
            fail("Malformed import statement")
        else if (length(tokens) >= 6) && ((tokens:2) == "as")
                                     && isValidId(tokens:3) then
            if !checkFor(tokens:(4..length(tokens)), ";") then
                fail("Missing semicolon or newline in import")
            else
                let body = recur(tokens:(5..length(tokens)))
                if !body.wellFormed then fail(body.error) else
                { ast: { type: "import",
                         module: tokens:1,
                         identifier: tokens:3,
                         body: body.ast },
                  rest: body.rest,
                  wellFormed: true }
        else
            if !checkFor(tokens:(2..length(tokens)), ";") then
                fail("Missing semicolon or newline in import")
            else
                let body = recur(tokens:(3..length(tokens)))
                if !body.wellFormed then fail(body.error) else
                { ast: { type: "import",
                         module: tokens:1,
                         identifier: tokens:1,
                         body: body.ast },
                  rest: body.rest,
                  wellFormed: true }
    else
        parse(opsByPrec, tokens)

let convertImports = (tree :: Object) =>
    if tree.type == "import" then
        let body = recur(tree.body)
        if !body.wellFormed then body else
        { ast: { type: "assignment",
                 identifier: tree.identifier,
                 value: { type: "lookup",
                          identifier: "module " + tree.module },
                 body: body.ast },
          modules: [tree.module] + body.modules,
          wellFormed: true }
    else
        { ast: tree, modules: [], wellFormed: true }


let loadAndParseFile = (filename :: [Int64]) =>
    let tree = parseWithImports(tokenize(IO.read(filename)))
    if !tree.wellFormed then tree else convertImports(tree.ast)


let resolveModule = (currentModule :: [Int64], newModuleName :: [Int64]) =>
    let slashIndex = utils.lastCharIndex(currentModule, 47) /* slash */
    let path = if slashIndex < 0 then "" else currentModule:(0..(slashIndex+1))
    path + newModuleName


let stripPath = (moduleName :: [Int64]) =>
    let slashIndex = utils.lastCharIndex(moduleName, 47)
    if slashIndex < 0 then moduleName 
                      else moduleName:((slashIndex+1)..length(moduleName))


let loadProgramAndImports = (module :: [Int64]) =>
    let program = loadAndParseFile(module + ".vzp")
    if !program.wellFormed then fail(program.error) else
    let recFunc = recur
    let f = (loadedModules :: Object, moduleName :: [Int64]) =>
        if utils.in(moduleName, 
                    ((x :: Object) => x.path) $ loadedModules.modules) then
            loadedModules
        else
            let recResult = recFunc(moduleName)
            if !recResult.wellFormed then
                recResult
            else
                let paths = ((x :: Object) => x.path) $ recResult.modules
                { modules: recResult.modules
                    + ([] @ (list :: [Object], m :: Object) =>
                        if utils.in(m.path, paths)
                            then list else list + [m])(loadedModules.modules),
                  wellFormed: true }

    let resolvedModules = ((x :: [Int64]) => 
                                resolveModule(module, x)) $ program.modules

    let results = (resolvedModules ^ { modules: [], wellFormed: true } @ f)
    if !results.wellFormed then
        results
    else
        { modules: results.modules + [{ name: stripPath(module),
                                        path: module,
                                        value: program.ast }],
          wellFormed: true }


/* Set everything up in the proper let bindings 
 * Currently, this assumes that we won't ever load multiple modules with the
 * same name (filename minus the extension). Will need to improve it later. */
let generateFinalProgram = (modules :: [Object]) =>
    if modules == [] then fail("No program!")
    else if length(modules) == 1 then
        { ast: (modules:0).value, wellFormed: true }
    else
        let body = recur(modules:(1..length(modules)))
        if !body.wellFormed then body else
        { ast: { type: "assignment",
                 identifier: "module " + (modules:0).name,
                 value: (modules:0).value,
                 body: body.ast },
          wellFormed: true }


/* Export a nice function that the typechecker can call */
(module :: [Int64]) =>
    let modules = loadProgramAndImports(module)
    if !modules.wellFormed then
        let unused = print(modules.error)
        { type: "number", value: 1 }
    else
        let finalProgram = generateFinalProgram(modules.modules)
        if !finalProgram.wellFormed then
            let unused = print(finalProgram.error)
            { type: "number", value: 1 }
        else
            finalProgram.ast
