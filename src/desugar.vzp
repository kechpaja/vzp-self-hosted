import typecheck
import utils

let objectOffset = 1
let typeOffset = 0

let ids = (objList :: [Object]) => ((x :: Object) => x.identifier) $ objList
let params = (objList :: [Object]) => ((x :: Object) => x.param) $ objList
let values = (objList :: [Object]) => ((x :: Object) => x.value) $ objList

let desugar_main = (ast :: Object) =>
    if ast.type == "array" then
        { type: "array",
          contents: recur $ ast.contents }
    else if ast.type == "assignment" then
        { type: "assignment",
          identifier: ast.identifier,
          value: recur(ast.value),
          body: recur(ast.body) }
    else if ast.type == "call" then
        if ast.func.ann.category == "type" then
            { type: "array",
              contents: [recur(ast.func)] + recur $ ast.args }
        else
            { type: "call",
              func: recur(ast.func),
              args: recur $ ast.args }
        /* TODO Stuff with builtins for overloading? */
    else if ast.type == "conditional" then
        { type: "conditional",
          cond: recur(ast.cond),
          thn: recur(ast.thn),
          els: recur(ast.els) }
    else if ast.type == "field_access" then
        if ast.obj.ann.category == "named" && ast.obj.ann.name == "Object"
                || ast.obj.ann.category == "array" 
                || ast.obj.ann.category == "dummy" then
            { type: "field_access",
              obj: recur(ast.obj),
              field: ast.field }
        else if ast.obj.ann.category == "type" then /* TODO do we need this? */
            let index = utils.strIndexInArray(ast.field,
                                              ids(ast.obj.ann.statics))
            { type: "call",
              func: { type: "lookup", identifier: ":" },
              args: [ recur(ast.obj),
                      { type: "number", value: index + typeOffset } ] }
        else
            /* TODO someday we'll have methods here too! And defaults! */
            let index = utils.strIndexInArray(ast.field,
                                              params(ast.obj.ann.fields))
            { type: "call", /* TODO got to add a subscript variant */
              func: { type: "lookup", identifier: ":" },
              args: [ recur(ast.obj), 
                      { type: "number", value: index + objectOffset } ] }
    else if ast.type == "lambda" then
        { type: "lambda",
          params: ast.params,
          body: recur(ast.body) }
    else if ast.type == "lookup" then
        { type: "lookup",
          identifier: ast.identifier }
    else if ast.type == "number" then
        { type: "number",
          value: ast.value }
    else if ast.type == "object" then
        let recFunc = recur
        { type: "object",
          contents: ((x :: Object) => { 
              identifier: x.identifier,
              value: recFunc(x.value)
          }) $ ast.contents }
    else if ast.type == "type" then
        /* This will not allow for inheritance. Giving each type a pointer back
         * to its supertype will require mutation, which I'm not ready to put
         * in at this point. But we can change that later when we actually have
         * methods, and we might just stick all the methods in every type or
         * something like that as a hack at first. */
        { type: "array",
          contents: recur $ values(ast.statics) }
    else
        ast


(module_name :: [Int64]) => desugar_main(typecheck(module_name))
