import DesugaredAst
import IdValuePair
import typecheck
import utils

let objectOffset = 1
let typeOffset = 0

let ids = (objList :: [Object]) => ((x :: Object) => x.identifier) $ objList
let params = (objList :: [Object]) => ((x :: Object) => x.param) $ objList
let values = (objList :: [Object]) => ((x :: Object) => x.value) $ objList

let restOf = (list :: [Object]) => 
    if length(list) <= 1 then [] else list:(1..length(list))

let desugar_main = (ast :: Object) =>
    if ast.type == "array" then
        DesugaredAst.array(recur $ ast.contents)
    else if ast.type == "assignment" then
        DesugaredAst.assignment(ast.identifier,
                                recur(ast.value),
                                recur(ast.body))
    else if ast.type == "call" then
        if ast.func.ann.category == "type" then
            DesugaredAst.array([recur(ast.func)] + recur $ ast.args)
        else
            DesugaredAst.call(recur(ast.func), recur $ ast.args)
        /* TODO Stuff with builtins for overloading? */
    else if ast.type == "conditional" then
        DesugaredAst.conditional(recur(ast.cond),
                                 recur(ast.thn),
                                 recur(ast.els))
    else if ast.type == "field_access" then
        if ast.obj.ann.category == "named" && ast.obj.ann.name == "Object"
                || ast.obj.ann.category == "array" 
                || ast.obj.ann.category == "dummy" then
            DesugaredAst.field_access(recur(ast.obj), ast.field)
        else if ast.obj.ann.category == "type" then /* TODO do we need this? */
            let index = utils.strIndexInArray(ast.field,
                                              ids(ast.obj.ann.statics))
            DesugaredAst.call(
                DesugaredAst.lookup(":"),
                [recur(ast.obj), DesugaredAst.number(index + typeOffset)]
            )
        else
            /* TODO someday we'll have methods here too! And defaults! */
            let index = utils.strIndexInArray(ast.field,
                                              params(ast.obj.ann.fields))
            DesugaredAst.call(
                DesugaredAst.lookup(":"),
                [recur(ast.obj), DesugaredAst.number(index + objectOffset)]
            )
    else if ast.type == "lambda" then
        DesugaredAst.lambda(ast.params, recur(ast.body))
    else if ast.type == "lookup" then
        DesugaredAst.lookup(ast.identifier)
    else if ast.type == "number" then
        DesugaredAst.number(ast.value)
    else if ast.type == "object" then
        let recFunc = recur
        DesugaredAst.object(((x :: Object) =>
            IdValuePair</DesugaredAst/>(x.identifier, recFunc(x.value))
        ) $ ast.contents)
    else if ast.type == "switch" then
        /* XXX This only works for single-level types. It needs to be expanded.
         * Need to do something like "is subtype of" as well as instance of. */
        let recFunc = recur
        let handleCases = (cases :: [Object], bottom :: DesugaredAst) =>
            if cases == [] then bottom else
            DesugaredAst.conditional(
                DesugaredAst.call(
                    DesugaredAst.lookup("=="),
                    [recFunc((cases:0).left),
                     DesugaredAst.call(
                        DesugaredAst.lookup(":"),
                        [DesugaredAst.lookup("x x"), DesugaredAst.number(0)])]
                ),
                DesugaredAst.assignment("that",
                                        DesugaredAst.lookup("x x"),
                                        recFunc((cases:0).right)),
                recur(restOf(cases), bottom)
            )

        DesugaredAst.assignment("x x",
                                recur(ast.expr),
                                handleCases(ast.cases, recur(ast.els)))
    else /* type */
        /* This will not allow for inheritance. Giving each type a pointer back
         * to its supertype will require mutation, which I'm not ready to put
         * in at this point. But we can change that later when we actually have
         * methods, and we might just stick all the methods in every type or
         * something like that as a hack at first. */
        DesugaredAst.array(recur $ values(ast.statics))


(module_name :: [Int64]) => desugar_main(typecheck(module_name))
