import typecheck
import utils

let objectOffset = 1
let typeOffset = 0

let ids = (objList :: [Object]) => ((x :: Object) => x.identifier) $ objList
let params = (objList :: [Object]) => ((x :: Object) => x.param) $ objList
let values = (objList :: [Object]) => ((x :: Object) => x.value) $ objList

/*
 * Having an env here at all is a hacky solution, but it will get the job done.
 * We can create more informative annotations in a future incarnation of the
 * typechecker once we have user-defined types. 
 **/
let restOf = (list :: [Object]) =>
    if list.length <= 1 then [] else list:(1..(list.length-1))
let appendToEnv = (id :: [Int64], t :: Object, env :: [Object]) =>
    [{ id: id, t: t}] + env
let getFromEnv = (id :: [Int64], env :: [Object]) =>
    if env == [] then { category: "error", name: "unbound: " + id } else
    if (env:0).id == id then (env:0).t else recur(id, restOf(env))

let evalType = (x :: Object, env :: [Object]) => x /* TODO */

let desugar_main = (ast :: Object, env :: [Object]) =>
    let recSameEnv = let rf = recur; (x :: Object) => rf(x, env)

    if ast.type == "array" then
        { type: "array",
          contents: recSameEnv $ ast.contents }
    else if ast.type == "assignment" then
        if ast.value.ann.category == "type" then
            { type: "assignment",
              identifier: ast.identifier,
              value: recSameEnv(ast.value),
              body: recur(ast.body,
                          appendToEnv(ast.identifier, 
                                      evalType(ast.value, env),
                                      env)) }
        else
            { type: "assignment",
              identifier: ast.identifier,
              value: recSameEnv(ast.value),
              body: recSameEnv(ast.body) }
    else if ast.type == "call" then
        if ast.func.ann.category == "type" then
            { type: "array",
              contents: [recSameEnv(ast.func)] + recSameEnv $ ast.args }
        else
            { type: "call",
              func: recSameEnv(ast.func),
              args: recSameEnv $ ast.args }
        /* TODO Stuff with builtins for overloading? */
    else if ast.type == "conditional" then
        { type: "conditional",
          cond: recSameEnv(ast.cond),
          thn: recSameEnv(ast.thn),
          els: recSameEnv(ast.els) }
    else if ast.type == "field_access" then
        if ast.obj.ann.category == "named" && ast.obj.ann.name == "Object"
                || ast.obj.ann.category == "array" 
                || ast.obj.ann.category == "dummy" then
            { type: "field_access",
              obj: recSameEnv(ast.obj),
              field: ast.field }
        else if ast.obj.ann.category == "type" then /* TODO do we need this? */
            let ty = evalType(ast.obj, env)
            let index = utils.strIndexInArray(ast.field, ids(ty.statics))
            { type: "call",
              func: { type: "lookup", identifier: ":" },
              args: [ recSameEnv(ast.obj),
                      { type: "number", value: index + typeOffset } ] }
        else
            /* TODO someday we'll have methods here too! And defaults! */
            let ty = evalType({ type: "lookup",
                                identifier: ast.obj.ann.name }, env)
            let index = utils.strIndexInArray(ast.field, params(ty.fields))
            { type: "call", /* TODO got to add a subscript variant */
              func: { type: "lookup", identifier: ":" },
              args: [ recSameEnv(ast.obj), 
                      { type: "number", value: index + objectOffset } ] }
    else if ast.type == "lambda" then
        { type: "lambda",
          params: ast.params,
          body: recSameEnv(ast.body) }
    else if ast.type == "lookup" then
        { type: "lookup",
          identifier: ast.identifier }
    else if ast.type == "number" then
        { type: "number",
          value: ast.value }
    else if ast.type == "object" then
        { type: "object",
          contents: ((x :: Object) => { 
              identifier: x.identifier,
              value: recSameEnv(x.value)
          }) $ ast.contents }
    else if ast.type == "type" then
        /* This will not allow for inheritance. Giving each type a pointer back
         * to its supertype will require mutation, which I'm not ready to put
         * in at this point. But we can change that later when we actually have
         * methods, and we might just stick all the methods in every type or
         * something like that as a hack at first. */
        { type: "array",
          contents: recSameEnv $ values(ast.statics) }
    else
        ast


(module_name :: [Int64]) => desugar_main(typecheck(module_name), [])
