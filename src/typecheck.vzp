import ast as A
import parse
import utils

let restOf = (list :: [Object]) =>
    if list.length < 2 then [] else list:(1..(list.length-1))

/* Stuff related to types themselves */
let narrowest = { category: "dummy", name: "narrowest" } /* Unifies w/ x as x */
let int64 = { category: "named", name: "Int64", args: [] }
let boolean = { category: "named", name: "Boolean", args: [] }
let object = { category: "named", name: "Object", args: [] }

let array = (x :: Object) => { category: "array", contents: x }
let function = (ps :: [Object], r :: Object) =>
    { category: "function", return: r, params: ps }

let stringifyType = (t :: Object) =>
    if t.category == "array" then
        "[" + recur(t.contents) + "]"
    else if t.category == "function" then
        "(" + utils.join(recur $ t.params) + ") -> " + recur(t.return)
    else if t.category == "named" || t.category == "dummy" then
        t.name
    else if t.category == "type" || t.category == "user-defined" then
        let recFunc = recur
        t.category + (if t.category == "user-defined" 
                      then "(" + utils.itoa(t.id) + ")" 
                      else "") + " - fields: "
        + ((x :: Object, s :: [Int64]) => 
            x.param + " :: <" + recFunc(x.ann) + "> " + s) @> t.fields ""
        + "statics: <|"
        + ((x :: Object, s :: [Int64]) => 
            x.identifier + " :: <stuff> " + s) @> t.statics "|>"
    else if t.category == "error" then
        "Error: " + t.name
    else
        "UNKNOWNTYPE(" + t.category + ")" /*"" + t*/

/* TODO For now we handle objects as just named types, and don't look inside.
 * But eventually we're going to have to look inside. We will also need to 
 * eventually distinguish between unifying to the most general and unifying to
 * the most specific type. */
let unify = (t1 :: Object, t2 :: Object) =>
    if t1.category == "error" then t1
    else if t2.category == "error" then t2
    else if t1.category == "dummy" && t1.name == "narrowest" then t2
    else if t2.category == "dummy" && t2.name == "narrowest" then t1

    else if t1.category != t2.category then 
        { category: "error",
          name: "incompatible types: " + stringifyType(t1) + ", "
                                       + stringifyType(t2) }
    else if t1.category == "named" then
        if t1.name == t2.name then t1 else
        { category: "error",
          name: "named types do not match: " + t1.name + ", " + t2.name }

    else if t1.category == "user-defined" then
        if t1.id == t2.id then t1 else {
            category: "error",
            name: "User-defined type mismatch: { " + stringifyType(t1)
                                     + " } and { " + stringifyType(t2) + " }"
        }
    else if t1.category == "array" then
        let inner = recur(t1.contents, t2.contents)
        if inner.category == "error" then
            { category: "error", name: "array types: " + stringifyType(t1)
                                                + ", " + stringifyType(t2) }
        else
            array(inner)
    else if t1.category == "function" then
        let unifiedReturn = recur(t1.return, t2.return)
        if unifiedReturn.category == "error" then
            { category: "error", name: "return: " + unifiedReturn.name } 
        else if t1.params.length != t2.params.length then
            { category: "error", name: "arity mismatch" }
        else

        let recFunc = recur
        let unifyTwoLists = (x :: [Object], y :: [Object]) =>
            if x == [] then [] else 
            [recFunc(x:0, y:0)] + recur(restOf(x), restOf(y))

        /* TODO condense errors? */

        function(unifyTwoLists(t1.params, t2.params), unifiedReturn)

        /* That's a hack for functions. Need to do what we do for arrays. */
    else
        {category: "error",
         name: "unrecognized type category: " + t1.category
                + " occurred with " + stringifyType(t2) }

let unifyList = (list :: [Object]) => unify @> list narrowest

let appendToEnv = (id :: [Int64], t :: Object, env :: [Object]) =>
    [{ id: id, t: t}] + env
let getFromEnv = (id :: [Int64], env :: [Object]) =>
    if env == [] then { category: "error", name: "unbound: " + id } else
    if (env:0).id == id then (env:0).t else recur(id, restOf(env))
let isInEnv = (id :: [Int64], env :: [Object]) => 
    if env == [] then false else
    if (env:0).id == id then true else recur(id, restOf(env))


let subs = (tast :: Object, env :: [Object]) =>
    let recFunc = recur
    let recWithSameEnv = (a :: Object) => recFunc(a, env)
    if tast.category == "named" && isInEnv(tast.name, env) then
        let ty = getFromEnv(tast.name, env)
        if ty.category != "type" && ty.category != "user-defined" then ty else
        let e = if ty.params.length == 0 then env else 
            ((i :: Int64, nv :: [Object]) =>
                appendToEnv(ty.params:i, recWithSameEnv(tast.args:i), nv)
            ) @> 0..(ty.params.length-1) env

        { category: "user-defined",
          id: ty.id,
          fields: ((x :: Object) => { param: x.param,
                                      ann: recFunc(x.ann, e) }) $ ty.fields,
          statics: ((x :: Object) => {
              identifier: x.identifier,
              value: recFunc(x.value, e)
          }) $ ty.statics,
          params: ty.params }
        /* TODO this is probably broken, but we tried. */
    else if tast.category == "user-defined" || tast.category == "type" then
        { category: "user-defined",
          id: tast.id,
          fields: ((x :: Object) => { param: x.param,
                                      ann: recFunc(x.ann, env) }) $ tast.fields,
          statics: ((x :: Object) => {
              identifier: x.identifier,
              value: recFunc(x.value, env)
          }) $ tast.statics,
          params: tast.params }
    else if tast.category == "array" then
        array(recur(tast.contents, env))
    else if tast.category == "function" then
        function(recWithSameEnv $ tast.params, recWithSameEnv(tast.return))
    else /* TODO objects? */
        tast

/* Returns a new AST with annotations */
let typecheck = (ast :: Object, env :: [Object]) =>
    let recWithSameEnv = let rf = recur; (x :: Object) => rf(x, env)

    if ast.type == "array" then
        let newContents = recWithSameEnv $ ast.contents
        let innerType = unifyList(((x :: Object) => x.ann) $ newContents)
        if innerType.category == "error" then 
            { type: "array",
              contents: newContents,
              ann: { category: "error",
                     name: "array: " + innerType.name } }
        else
            { type: "array",
              contents: newContents,
              ann: array(innerType) }
    else if ast.type == "assignment" then
        let newValue = recur(ast.value, env)
        /* TODO error case! */
        let newBody = recur(ast.body, appendToEnv(ast.identifier,
                                                  newValue.ann,
                                                  env))
        { type: "assignment",
          identifier: ast.identifier,
          value: newValue,
          body: newBody,
          ann: newBody.ann }
    else if ast.type == "call" then
        if ast.func.type == "call" && ast.func.func.type == "lookup"
            && ast.func.func.identifier == "~" && ast.func.args.length == 2 then
            recur({ type: "call",
                    func: ast.func.args:1,
                    args: [ast.func.args:0] + ast.args }, env)
        else
        let newFunc = recur(ast.func, env)
        let newArgs = recWithSameEnv $ ast.args
        let argTypes = ((x :: Object) => x.ann) $ newArgs

        /* Special cases for builtins! */
        if newFunc.type == "lookup" && newFunc.identifier == "~"
                                    && newArgs.length == 2 then
            if (newArgs:1).ann.category != "function" then
                { type: "lambda",
                  params: [],
                  body: { type: "lookup", identifier: " " },
                  ann: { category: "error", name: "Non-function in rhs of ~" } }
            else if (newArgs:1).ann.params.length < 1 then
                { type: "lambda",
                  params: [],
                  body: { type: "lookup", identifier: " " },
                  ann: { category: "error",
                         name: "Rhs of ~ takes no arguments" } }
            else
            let merged = unify((newArgs:1).ann.params:0, (newArgs:0).ann)
            if merged.category == "error" then
                { type: "lambda",
                  params: [],
                  body: { type: "lookup", identifier: " " },
                  ann: merged }
            else
                let throwaway = (newArgs:1).ann.params
                let prms = if throwaway.length == 1 then []
                           else throwaway:(1..(throwaway.length-1))
                let indices = 0..(prms.length-1)
                let fparams = ((i :: Int64) => "x " + utils.itoa(i)) $ indices
                let fargs = ((i :: Int64) => { type: "lookup",
                                               identifier: "x " + utils.itoa(i),
                                               ann: prms:i }) $ indices
                { type: "lambda",
                  params: fparams,
                  body: { type: "call",
                          func: newArgs:1,
                          args: [newArgs:0] + fargs },
                  ann: function(prms, (newArgs:1).ann.return) }
        else if newFunc.type == "lookup" && utils.in(newFunc.identifier,
                                                ["==", "!="])
                                    && newArgs.length == 2 then
            let unified = unify((newArgs:0).ann, (newArgs:1).ann)
            if unified.category == "error" then
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: unified }
            else if newFunc.identifier == "!=" then
                { type: "call",
                  func: { type: "lookup", identifier: "!", ann: narrowest },
                  args: [ { type: "call",
                            func: { type: "lookup",
                                    identifier: "==",
                                    ann: newFunc.ann },
                            args: newArgs,
                            ann: boolean } ],
                  ann: boolean }
            else
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: boolean }
        else if newFunc.type == "lookup" && newFunc.identifier == "+"
                                         && newArgs.length == 2 then
            let argsType = unify((newArgs:0).ann, (newArgs:1).ann)
            if argsType.category == "named" && argsType.name == "Int64" then
                { type: "call",
                  func: { type: "lookup",
                          identifier: "+",
                          ann: function([int64, int64], int64) },
                  args: newArgs,
                  ann: argsType }
            else if argsType.category == "array" then
                { type: "call",
                  func: { type: "lookup",
                          identifier: "++",
                          ann: function([argsType, argsType], argsType) },
                  args: newArgs,
                  ann: argsType }
            else if argsType.category == "error" then
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: argsType }
            else
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: narrowest }
        else if newFunc.type == "lookup" && newFunc.identifier == "++"
                                         && newArgs.length == 2 then
            let argsType = unify((newArgs:0).ann, (newArgs:1).ann)
            if argsType.category == "array" then
                { type: "call",
                  func: { type: "lookup",
                          identifier: "++",
                          ann: function([argsType, argsType], argsType) },
                  args: newArgs,
                  ann: argsType }
            else
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: { category: "error",
                         name: "Non-array as arg to ++: "
                            + stringifyType(argsType) } }
        else if newFunc.type == "lookup" && newFunc.identifier == "$"
                                         && newArgs.length == 2 then
            if (newArgs:0).ann.category == "function" 
                    && (newArgs:0).ann.params.length == 1
                    && (((newArgs:1).ann.category == "array"
                        && unify((newArgs:0).ann.params:0,
                                 (newArgs:1).ann.contents).category != "error")
                        || (newArgs:1).ann.category == "dummy") then
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: array((newArgs:0).ann.return) }
            else
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: { category: "error",
                         name: "mismatch in $: " + stringifyType((newArgs:0).ann)
                            + " can't handle contents of " 
                            + stringifyType((newArgs:1).ann) } }
        else if newFunc.type == "lookup" && newFunc.identifier == ":"
                                         && newArgs.length == 2 then
            if (newArgs:0).ann.category == "array"
                    && (newArgs:1).ann.category == "named"
                    && (newArgs:1).ann.name == "Int64" then
                { type: "call",
                  func: { type: "lookup",
                          identifier: ":",
                          ann: narrowest },
                  args: newArgs,
                  ann: (newArgs:0).ann.contents }
            else if (newArgs:0).ann.category == "dummy"
                    && (newArgs:1).ann.category == "named"
                    && (newArgs:1).ann.name == "Int64" then
                { type: "call",
                  func: { type: "lookup",
                          identifier: ":",
                          ann: narrowest },
                  args: newArgs,
                  ann: narrowest }
            else if (newArgs:0).ann.category == "dummy"
                    && (newArgs:1).ann.category == "dummy" then
                { type: "call",
                  func: { type: "lookup",
                          identifier: "[]", /* TODO only needed if we can't type the args*/
                          ann: newFunc.ann },
                  args: newArgs,
                  ann: narrowest }
            else if ((newArgs:0).ann.category == "array"
                    || (newArgs:0).ann.category == "dummy")
                    && (newArgs:1).ann.category == "array"
                    && (newArgs:1).ann.contents.category == "named"
                    && (newArgs:1).ann.contents.name == "Int64" then
                { type: "call", /* TODO this should be recursive */
                  func: { type: "lookup",
                          identifier: "$",
                          ann: (newArgs:0).ann },
                  args: [ { type: "lambda",
                            params: [ " " ],
                            body: { type: "call",
                                    func: { type: "lookup",
                                            identifier: ":",
                                            ann: narrowest },
                                    args: [ newArgs:0,
                                            { type: "lookup",
                                              identifier: " ",
                                              ann: int64 } ],
                                    ann: narrowest }, /* TODO real ann */
                            ann: function([int64], narrowest) }, /*TODO eventually array contents*/
                          newArgs:1 ],
                  ann: (newArgs:0).ann }
            else
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: { category: "error",
                         name: "incompatible types in ':'" } }
        else if newFunc.type == "lookup" && newFunc.identifier == "@>"
                                         && newArgs.length == 3 then
            let one = (newArgs:0).ann
            let two = (newArgs:1).ann
            let three = (newArgs:2).ann
            if one.category == "function" && one.params.length == 2
                    && (two.category == "array"
                        && unify(one.params:0,
                                 two.contents).category != "error")
                        || two.category == "dummy" then
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: unify(one.return, unify(one.params:1, three)) }
            else
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: { category: "error",
                         name: "type mismatch in @>: " + stringifyType(one)
                            + " " + stringifyType(two) + " "
                            + stringifyType(three) } }
        else if newFunc.type == "lookup" && newFunc.identifier == "<@"
                                         && newArgs.length == 3 then
            let one = (newArgs:0).ann
            let two = (newArgs:1).ann
            let three = (newArgs:2).ann
            if one.category == "function" && one.params.length == 2
                    && three.category == "array"
                    && unify(one.params:1,
                             three.contents).category != "error" then
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: unify(one.return, unify(one.params:0, two)) }
            else
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: { category: "error", name: "type mismatch in <@" } }

        /* TODO */
        /* Allow us to call object fields. Remove when we type object fields. */
        else if newFunc.ann.category == "dummy" then
            { type: "call",
              func: newFunc,
              args: newArgs,
              ann: narrowest }
        else if newFunc.ann.category == "type" then
            { type: "call",
              func: newFunc,
              args: newArgs,
              ann: { category: "user-defined",
                     id: newFunc.ann.id,
                     fields: newFunc.ann.fields,
                     statics: newFunc.ann.statics,
                     params: newFunc.ann.params } } /* TODO check args */
        else if newFunc.ann.category == "error" then
            { type: "call",
              func: newFunc,
              args: newArgs,
              ann: newFunc.ann }
        else
            let recFunc = recur
            /* This assumes that the lists are the same length */
            let checkArgs = (a1 :: [Object], a2 :: [Object]) =>
                if a1 == [] || a2 == [] then "" else
                let unified = unify(a1:0, a2:0)
                let recResult = recur(restOf(a1), restOf(a2))
                if unified.category == "error" then
                    unified.name + recResult
                else
                    ""

            if ast.args.length != newFunc.ann.params.length then
                { type: "call",
                  func: newFunc,
                  args: newArgs,
                  ann: { category: "error", name: "arity mismatch" } }
            else 
                let x = checkArgs(argTypes, newFunc.ann.params)
                if x != "" then
                    { type: "call",
                      func: newFunc,
                      args: newArgs,
                      ann: { category: "error", name: "arg types: " + x } }
                else
                    { type: "call",
                      func: newFunc,
                      args: newArgs,
                      ann: if newFunc.ann.return.category == "type"
                           then { category: "user-defined",
                                  id: newFunc.ann.return.id,
                                  fields: newFunc.ann.return.fields,
                                  statics: newFunc.ann.return.statics,
                                  params: newFunc.ann.return.params }
                           else newFunc.ann.return }
    else if ast.type == "conditional" then
        let newCond = recur(ast.cond, env)
        let newThn = recur(ast.thn, env)
        let newEls = recur(ast.els, env)
        if newCond.ann.category == "error" then
            { type: "conditional",
              cond: newCond,
              thn: newThn,
              els: newEls,
              ann: newCond.ann }
        else if newCond.ann.category == "dummy" || 
                    newCond.ann.category == "named" 
                 && newCond.ann.name == "Boolean" then
            let newType = unify(newThn.ann, newEls.ann)
            { type: "conditional",
              cond: newCond,
              thn: newThn,
              els: newEls,
              ann: newType }
        else 
            { type: "conditional",
              cond: newCond,
              thn: newThn,
              els: newEls,
              ann: { category: "error", name: "Cond requires a boolean." } }
    else if ast.type == "field_access" then
        let newObj = recur(ast.obj, env)
        if newObj.ann.category == "type" then
            let index = utils.strIndexInArray(
                ast.field,
                ((x :: Object) => x.identifier) $ newObj.ann.statics
            )

            if index < 0 then
                { type: "field_access",
                  obj: newObj,
                  field: ast.field,
                  ann: { category: "error", name: "No subtype '" + ast.field } }
            else
                { type: "field_access",
                  obj: newObj,
                  field: ast.field,
                  ann: (newObj.ann.statics:index).value }
        else if newObj.ann.category == "user-defined" then
            let index = utils.strIndexInArray(
                ast.field,
                ((x :: Object) => x.param) $ newObj.ann.fields
            )

            if index < 0 then
                { type: "field_access",
                  obj: newObj,
                  field: ast.field,
                  ann: { category: "error",
                         name: "No field '" + ast.field + "' in "
                          + ((x :: Object, y :: [Int64]) => 
                                x.param + ": " + stringifyType(x.ann) + ", " + y
                            ) @> newObj.ann.fields "" } }
            else
                { type: "field_access",
                  obj: newObj,
                  field: ast.field,
                  ann: (newObj.ann.fields:index).ann }
        else if newObj.ann.category == "array" && ast.field == "length" then
            { type: "field_access", /* XXX Get rid of this special case if we */
              obj: newObj,          /* ever replace .length */
              field: ast.field,
              ann: int64 }
        else if !(newObj.ann.category == "named"
                  || newObj.ann.category == "dummy") then
            { type: "field_access",
              obj: newObj,
              field: ast.field,
              ann: { category: "error",
                     name: "field access: " + A.stringifyAst(ast) + " . "
                                        + " // " + stringifyType(newObj.ann) } }
        else
            { type: "field_access",
              obj: newObj,
              field: ast.field,
              ann: narrowest } /* TODO eventually check types of fields */
    else if ast.type == "lambda" then
        let midEnv = ((p :: Object, e :: [Object]) => 
            appendToEnv(p.param, subs(p.ann, env), e)) @> ast.params env
        let paramsWithoutTypes = ((p :: Object) => p.param) $ ast.params
        let paramTypes = ((x :: Object) => subs(x.ann, env)) $ ast.params
        let expectedReturnType = subs(ast.returnType, env)
        let newEnv = appendToEnv("recur",
                                 function(paramTypes, expectedReturnType),
                                 midEnv)
        let oldNewBody = recur(ast.body, newEnv)
        let newBody = recur(
            ast.body,
            appendToEnv("recur", function(paramTypes, oldNewBody.ann), midEnv)
        )
        let returnType = unify(expectedReturnType, newBody.ann)
        if returnType.category == "error" then
            { type: "lambda",
              params: paramsWithoutTypes,
              body: newBody,
              ann: returnType }
        else
            { type: "lambda",
              params: paramsWithoutTypes,
              body: newBody,
              ann: function(paramTypes, returnType) }
    else if ast.type == "lookup" then
        { type: "lookup",
          identifier: ast.identifier,
          ann: getFromEnv(ast.identifier, env) }
    else if ast.type == "number" then
        { type: "number",
          value: ast.value,
          ann: int64 }
    else if ast.type == "object" then
        let recFunc = recur
        let handleKeyValuePair = (x :: Object) =>
            { identifier: x.identifier, value: recFunc(x.value, env) }
        let newContents = handleKeyValuePair $ ast.contents
        let forFold = (x :: Object, y :: [Int64]) =>
            if x.value.ann.category == "error" then
                x.value.ann.name + ", " + y
            else
                y
        let errorsString = forFold @> newContents ""
        if errorsString.length > 0 then
            { type: "object",
              contents: newContents,
              ann: { category: "error", name: "object: " + errorsString } }
        else
            { type: "object",
              contents: newContents,
              ann: object }
    else if ast.type == "parametrized" then
        let expr = recur(ast.expr, env)
        let args = ((x :: Object) => subs(x, env)) $ ast.types

        /* TODO look for unbounds and things like that */
        if expr.ann.category != "type" then
            { type: "type",
              ann: { category: "error", name: "Bad parametrized type" } }
        else if expr.ann.params.length != args.length then
            { type: "type",
              ann: { category: "error", name: "Arity mismatch, param'd type" } }
        else if args.length == 0 then
            expr
        else
            let newEnv = ((x :: Int64, e :: [Object]) => 
                appendToEnv(expr.ann.params:x, args:x, e)
            ) @> (0..(args.length-1)) env

            let ann = subs(expr.ann, newEnv)
            let newAnn = { category: "type",
                           id: ann.id,
                           fields: ann.fields,
                           statics: ann.statics,
                           params: ann.params }
            if expr.type == "lookup" then
                { type: "lookup",
                  identifier: expr.identifier,
                  ann: newAnn }
            else
                { type: "type",
                  statics: expr.ann.statics, /* TODO remove these? */
                  ann: newAnn }
    else if ast.type == "switch" then
        let recFunc = recur
        let expr = recur(ast.expr, env)
        let cases = ((x :: Object) =>
            /* TODO if left is just a bare type, then we don't have to do
             * anything special here. If it is a call, though, we have to 
             * pull the arguments out and bind them. 
             *
             * This more or less requires that we do some desugaring here. 
             * We have to bind the expr to something as well. */
            let left = recFunc(x.left, env)

            let right = recFunc(x.right, 
                                appendToEnv("that", 
                                            { category: "user-defined",
                                              id: left.ann.id,
                                              fields: left.ann.fields,
                                              statics: left.ann.statics,
                                              params: left.ann.params },
                                            env))
            { left: left, right: right }) $ ast.cases
        { type: "switch",
          expr: expr,
          cases: cases,
          els: { type: "number", value: 0 }, /* TODO should be from user! */
          ann: unifyList(((x :: Object) => x.right.ann) $ cases) }
    else if ast.type == "type" then
        let id = ENV.unique()

        ((typeAst :: Object, envv :: [Object]) => 
            let recFunc = recur
            let fieldTypes = ((a :: Object) => 
                subs(a, envv)
            ) $ (((x :: Object) => x.ann) $ typeAst.fields)

            let fieldEntries = if typeAst.fields.length > 0 then 
                    ((i :: Int64) => {
                        param: (typeAst.fields:i).param,
                        ann: fieldTypes:i
                    }) $ (0..(typeAst.fields.length-1)) 
                else []

            let sflds = ((x :: Object) => {
                identifier: x.identifier,
                value: recFunc(x.value, appendToEnv("self", 
                                                    { category: "type",
                                                      id: id,
                                                      fields: fieldEntries,
                                                      statics: [],
                                                      params: [] },
                                                    envv))
            }) $ typeAst.statics
            let annflds = ((x :: Object) => { identifier: x.identifier,
                                              value: x.value.ann }) $ sflds

            { type: "type",
              statics: sflds,
              ann: { category: "type",
                     id: id,
                     fields: fieldEntries,
                     statics: annflds,
                     params: ast.params } })(ast, env)
    else
        let asfd = print(ast)
        ast

/* ==, !=, +, $, @>, <@, : are handled separately. Some are still present
 * in this list; others will be added later. */
/* TODO ==, !=, $, @>, and <@ can be handled with type variables, which are
 * coming in a later version. Probably handling array concat that way too. */
let envWithBuiltins = [
    { id: "||", t: function([boolean, boolean], boolean) },
    { id: "&&", t: function([boolean, boolean], boolean) },
    { id: ">", t: function([int64, int64], boolean) },
    { id: ">=", t: function([int64, int64], boolean) },
    { id: "<", t: function([int64, int64], boolean) },
    { id: "<=", t: function([int64, int64], boolean) },
    { id: "+", t: function([int64, int64], int64) },
    { id: "-", t: function([int64, int64], int64) },
    { id: "*", t: function([int64, int64], int64) },
    { id: "/", t: function([int64, int64], int64) },
    { id: "%", t: function([int64, int64], int64) },
    { id: "..", t: function([int64, int64], array(int64)) },
    { id: "!", t: function([boolean], boolean) },
    { id: "unary -", t: function([int64], int64) },
    { id: "print", t: function([array(int64)], array(int64)) },
    { id: "true", t: boolean },
    { id: "false", t: boolean },
    { id: "IO", t: narrowest },
    { id: "ENV", t: narrowest }
]

/* TODO IO functions once object fields work */

/* TODO remember error checking when we call this */
let typecheck_main = (ast :: Object) =>
    let tc = typecheck(ast, envWithBuiltins)
    if tc.ann.category == "error" then
        let unused = print("Error: " + tc.ann.name)
        { type: "number", value: 1 }
    else
        tc

/* Export a nice simple function */
(program_as_string :: [Int64]) => typecheck_main(parse(program_as_string))
