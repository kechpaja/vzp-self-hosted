import FunctionWrapper
import IdValuePair
import JsAst
import TransformedAst
import transform
import utils

/* XXX still missing a few things I'm not ready to put straight into JS */
let binops = [ "==", ">", ">=", "<", "<=", "+", "-", "*", "/", "%", "++", "||",
               "&&", ":", "..", "$", "@" ]
let unops = [ "!", "unary -", "length" ]

let corefuncs = [ "slow=", "slow+", "@>", "<@", "print", "[]" ]

let unique = (list :: [[Int64]]) :: [[Int64]] =>
    if length(list) == 0 then [] else
    if length(list) == 1 then
        if utils.in(list:0, ["true", "false", "recur"]) then [] else list
    else
    let rec = recur(list:(1..length(list)))
    if utils.in(list:0, rec + ["true", "false", "recur"]) then 
        rec
    else
        [list:0] + rec

let DefuncWrapper = type {
    ast :: JsAst,
    funcs :: [FunctionWrapper],
    closure :: [[Int64]],
    builtins :: [[Int64]],
    count :: Int64
}

let ListRecWrapper = type {
    asts :: [JsAst],
    funcs :: [FunctionWrapper],
    closure :: [[Int64]],
    builtins :: [[Int64]],
    count :: Int64
}

/* TODO closure vars in here */
let listRec = (list :: [TransformedAst],
               f :: (TransformedAst, [[Int64]], Int64) DefuncWrapper,
               env :: [[Int64]],
               count :: Int64) :: ListRecWrapper =>
    ((a :: TransformedAst, saved :: ListRecWrapper) :: ListRecWrapper =>
        let handled = f(a, env, saved.count)
        ListRecWrapper(
            [handled.ast] + saved.asts,
            handled.funcs + saved.funcs,
            handled.closure + saved.closure,
            handled.builtins + saved.builtins,
            handled.count
        )) @> list ListRecWrapper([], [], [], [], count)

let defunc_main = (ast :: TransformedAst,
                   env :: [[Int64]],
                   count :: Int64) :: DefuncWrapper =>
    switch ast <|
        TransformedAst.array ->
            let results = listRec(that.contents, recur, env, count)
            DefuncWrapper(JsAst.array(results.asts),
                          results.funcs,
                          results.closure,
                          results.builtins,
                          results.count),
        TransformedAst.assignment ->
            let id = that.identifier
            let value = recur(that.value, env, count)
            let body = recur(that.body, [id] + env, value.count)
            DefuncWrapper(JsAst.assignment(id, value.ast, body.ast),
                          value.funcs + body.funcs,
                          value.closure + body.closure,
                          value.builtins + body.builtins,
                          body.count),
        TransformedAst.call ->
            let args = listRec(that.args, recur, env, count)
            let recFunc = recur
            let elseFunc = () =>
                let func = recFunc(that.func, env, args.count)
                DefuncWrapper(JsAst.call(JsAst.field_access(func.ast, "f"),
                                         [func.ast] + args.asts),
                              func.funcs + args.funcs,
                              func.closure + args.closure,
                              func.builtins + args.builtins,
                              func.count)

            switch that.func <|
                TransformedAst.array -> elseFunc(),
                TransformedAst.assignment -> elseFunc(),
                TransformedAst.call -> elseFunc(),
                TransformedAst.conditional -> elseFunc(),
                TransformedAst.field_access -> elseFunc(),
                TransformedAst.lambda -> elseFunc(),
                TransformedAst.lookup -> if length(args.asts) == 2
                                      && utils.in(that.identifier, binops) then
                        DefuncWrapper(JsAst.binop(that.identifier,
                                                  args.asts:0,
                                                  args.asts:1),
                                      args.funcs,
                                      args.closure,
                                      args.builtins,
                                      args.count)
                    else if length(args.asts) == 1
                                && utils.in(that.identifier, unops) then
                        DefuncWrapper(JsAst.unop(that.identifier,
                                                 args.asts:0),
                                      args.funcs,
                                      args.closure,
                                      args.builtins,
                                      args.count)
                    else elseFunc(),
                TransformedAst.number -> elseFunc(),
                TransformedAst.object -> elseFunc()
            |>,
        TransformedAst.conditional ->
            let cond = recur(that.cond, env, count)
            let thn = recur(that.thn, env, cond.count)
            let els = recur(that.els, env, thn.count)
            DefuncWrapper(JsAst.conditional(cond.ast, thn.ast, els.ast),
                          cond.funcs + thn.funcs + els.funcs,
                          cond.closure + thn.closure + els.closure,
                          cond.builtins + thn.builtins + els.builtins,
                          els.count),
        TransformedAst.field_access ->
            let obj = recur(that.obj, env, count)
            DefuncWrapper(JsAst.field_access(obj.ast, that.field),
                          obj.funcs,
                          obj.closure,
                          obj.builtins,
                          obj.count),
        TransformedAst.lambda ->
            let body = recur(that.body, that.params, count + 1)
            let closureIds = unique(body.closure)
            let newBody = ((x :: [Int64], inner :: JsAst) => JsAst.assignment(
                x,
                JsAst.field_access(JsAst.lookup("f"), x),
                inner
            )) @> closureIds body.ast
            let closure = ((x :: [Int64]) => IdValuePair</JsAst/>(
                x,
                JsAst.lookup(x)
            )) $ closureIds
            let funcid = "f" + utils.itoa(count)
            let funcPair = [IdValuePair</JsAst/>("f", JsAst.lookup(funcid))]
            DefuncWrapper(JsAst.object(closure + funcPair),
                          [FunctionWrapper(
                              funcid,
                              ["f"] + that.params,
                              JsAst.assignment("recur",
                                               JsAst.lookup("f"),
                                               newBody)
                          )] + body.funcs,
                          ((x :: [Int64], list :: [[Int64]]) =>
                              if utils.in(x, env) then list else [x] + list
                          ) @> closureIds [],
                          body.builtins,
                          body.count),
        TransformedAst.lookup ->
            let id = that.identifier 
            if utils.in(id, corefuncs) then
                /* Don't need to close over builtins, as they are defined globally.
                 * We do need to create primitive closures for them so that they 
                 * can be passed intuitively though.*/
                let obj = JsAst.object([
                    IdValuePair</JsAst/>("f", JsAst.lookup(id))
                ])
                DefuncWrapper(obj, [], [], [], count)
            else if utils.in(id, unops + binops) then
                /* These builtins can be generated */
                DefuncWrapper(JsAst.lookup(id), [], [], [id], count)
            else if !utils.in(id, env) then
                DefuncWrapper(JsAst.lookup(id), [], [id], [], count)
            else
                DefuncWrapper(JsAst.lookup(id), [], [], [], count),
        TransformedAst.number ->
            DefuncWrapper(JsAst.number(that.value), [], [], [], count),
        TransformedAst.object ->
            let f = (x :: IdValuePair</TransformedAst/>) => x.value
            let values = listRec(f $ that.contents, recur, env, count)
            let contents = ((i :: Int64) => IdValuePair</JsAst/>(
                                (that.contents:i).identifier,
                                values.asts:i
                            )) $ 0..length(that.contents)
            DefuncWrapper(JsAst.object(contents),
                          values.funcs,
                          values.closure,
                          values.builtins,
                          values.count)
    |>

let DefuncedProgram = type {
    ast :: JsAst,
    funcs :: [FunctionWrapper]
}

(program_as_string :: [Int64]) =>
    let firstStep = defunc_main(transform(program_as_string), [], 0)
    let addLets = (operation :: [Int64], ast :: JsAst) =>
        JsAst.assignment(
            operation,
            JsAst.object([
                IdValuePair</JsAst/>("f", JsAst.lookup("f" + operation))
            ]),
            ast
        ) 
    let generateFuncs = (operation :: [Int64]) =>
        if utils.in(operation, unops) then
            FunctionWrapper("f" + operation,
                            [ "f", "x" ],
                            JsAst.unop(operation, JsAst.lookup("x")))
        else
            FunctionWrapper("f" + operation,
                            [ "f", "x", "y" ],
                            JsAst.binop(operation, 
                                        JsAst.lookup("x"),
                                        JsAst.lookup("y")))
    let liftedBuiltins = unique(firstStep.builtins)
    DefuncedProgram(addLets @> liftedBuiltins firstStep.ast,
                    (generateFuncs $ liftedBuiltins) + firstStep.funcs)
