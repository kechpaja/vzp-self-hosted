import JsAst
import transform
import utils

let DefuncWrapper = type {
    ast :: JsAst,
    funcs :: [Object],
    closure :: [[Int64]],
    builtins :: [[Int64]],
    count :: Int64
}

/* XXX still missing a few things I'm not ready to put straight into JS */
let binops = [ ">", ">=", "<", "<=", "-", "*", "/", "%", "array+", "||", "&&" ]
let unops = [ "!", "unary -" ]

let corefuncs = [ "==", "!=", "+", "$", "@>", "<@", "print", ":", "..", "ref=" ]
let builtins = corefuncs + unops + binops

let unique = (list :: [[Int64]]) =>
    if list.length == 0 then [] else
    if list.length == 1 then
        if utils.in(list:0, ["true", "false", "recur"]) then [] else list
    else
    let rec = recur(list:(1..(list.length-1)))
    if utils.in(list:0, rec + ["true", "false", "recur"]) then 
        rec
    else
        [list:0] + rec

/* TODO closure vars in here */
let listRec = (list :: [Object],
               f :: (Object, [[Int64]], Int64) DefuncWrapper,
               env :: [[Int64]],
               count :: Int64) =>
    ((a :: Object, saved :: Object) =>
        let handled = f(a, env, saved.count)
        { asts: [handled.ast] + saved.asts,
          funcs: handled.funcs + saved.funcs,
          closure: handled.closure + saved.closure,
          builtins: handled.builtins + saved.builtins,
          count: handled.count }) @> list { asts: [],
                                            funcs: [],
                                            closure: [],
                                            builtins: [],
                                            count: count }

let defunc_main = (ast :: Object, env :: [[Int64]], count :: Int64) =>
    if ast.type == "array" then
        let results = listRec(ast.contents, recur, env, count)
        DefuncWrapper(JsAst.array(results.asts),
                      results.funcs,
                      results.closure,
                      results.builtins,
                      results.count)
    else if ast.type == "call" then
        let args = listRec(ast.args, recur, env, count)
        if args.asts.length == 2 && ast.func.type == "lookup"
                                 && utils.in(ast.func.identifier, binops) then
            DefuncWrapper(JsAst.binop(ast.func.identifier, args.asts:0, args.asts:1),
                          args.funcs,
                          args.closure,
                          args.builtins,
                          args.count)
        else if args.asts.length == 1 && ast.func.type == "lookup"
                                    && utils.in(ast.func.identifier, unops) then
            DefuncWrapper(JsAst.unop(ast.func.identifier, args.asts:0),
                          args.funcs,
                          args.closure,
                          args.builtins,
                          args.count)
        else
            let func = recur(ast.func, env, args.count)
            DefuncWrapper(JsAst.call(JsAst.field_access(func.ast, "f"),
                                     [func.ast] + args.asts),
                          func.funcs + args.funcs,
                          func.closure + args.closure,
                          func.builtins + args.builtins,
                          func.count)
    else if ast.type == "field_access" then
        let obj = recur(ast.obj, env, count)
        DefuncWrapper(JsAst.field_access(obj.ast, ast.field),
                      obj.funcs,
                      obj.closure,
                      obj.builtins,
                      obj.count)
    else if ast.type == "js-assignment" then
        let value = recur(ast.value, env, count)
        let body = recur(ast.body, [ast.identifier] + env, value.count)
        DefuncWrapper(JsAst.assignment(ast.identifier, value.ast, body.ast),
                      value.funcs + body.funcs,
                      value.closure + body.closure,
                      value.builtins + body.builtins,
                      body.count)
    else if ast.type == "js-conditional" then
        let cond = recur(ast.cond, env, count)
        let thn = recur(ast.thn, env, cond.count)
        let els = recur(ast.els, env, thn.count)
        DefuncWrapper(JsAst.conditional(cond.ast, thn.ast, els.ast),
                      cond.funcs + thn.funcs + els.funcs,
                      cond.closure + thn.closure + els.closure,
                      cond.builtins + thn.builtins + els.builtins,
                      els.count)
    else if ast.type == "lambda" then
        let body = recur(ast.body, ast.params, count + 1)
        let closureIds = unique(body.closure)
        let newBody = ((x :: [Int64], inner :: Object) => JsAst.assignment(
            x,
            JsAst.field_access(JsAst.lookup("f"), x),
            inner
        )) @> closureIds body.ast
        let closure = ((x :: [Int64]) => 
                            { identifier: x,
                              value: JsAst.lookup(x) }) $ closureIds
        let funcPair = [{ identifier: "f",
                          value: JsAst.lookup("f" + utils.itoa(count)) }]
        DefuncWrapper(JsAst.object(closure + funcPair),
                      [{ name: "f" + utils.itoa(count),
                         params: ["f"] + ast.params,
                         body: JsAst.assignment("recur",
                                                JsAst.lookup("f"),
                                                newBody) }] + body.funcs,
                      ((x :: [Int64], list :: [[Int64]]) =>
                          if utils.in(x, env) then list 
                                              else [x] + list) @> closureIds [],
                      body.builtins,
                      body.count)
    else if ast.type == "object" then
        let values = listRec(((x :: Object) => x.value) $ ast.contents,
                             recur,
                             env,
                             count)
        let contents = if ast.contents.length > 0 then ((i :: Int64) => 
            { identifier: (ast.contents:i).identifier,
              value: values.asts:i }) $ 0..(ast.contents.length-1) else []
        DefuncWrapper(JsAst.object(contents),
                      values.funcs,
                      values.closure,
                      values.builtins,
                      values.count)
    else if ast.type == "lookup" then
        if utils.in(ast.identifier, corefuncs) then
            /* Don't need to close over builtins, as they are defined globally.
             * We do need to create primitive closures for them so that they 
             * can be passed intuitively though.*/
            DefuncWrapper(JsAst.object([{ 
                                            identifier: "f", 
                                            value: JsAst.lookup(ast.identifier)
                                       }]), [], [], [], count)
        else if utils.in(ast.identifier, unops + binops) then
            /* These builtins can be generated */
            let bltns = [ast.identifier]
            DefuncWrapper(JsAst.lookup(ast.identifier), [], [], bltns, count)
        else if !utils.in(ast.identifier, env) then
            let clsr = [ast.identifier]
            DefuncWrapper(JsAst.lookup(ast.identifier), [], clsr, [], count)
        else
            DefuncWrapper(JsAst.lookup(ast.identifier), [], [], [], count)
    else
        /* No other cases can contain functions. XXX should be a number. */
        DefuncWrapper(JsAst.number(ast.value), [], [], [], count)


(program_as_string :: [Int64]) =>
    let firstStep = defunc_main(transform(program_as_string), [], 0)
    let addLets = (operation :: [Int64], ast :: JsAst) =>
        JsAst.assignment(
            operation,
            JsAst.object([{ identifier: "f",
                            value: JsAst.lookup("f" + operation) }]),
            ast
        ) 
    let generateFuncs = (operation :: [Int64]) =>
        if utils.in(operation, unops) then
            { name: "f" + operation,
              params: [ "f", "x" ],
              body: JsAst.unop(operation, JsAst.lookup("x")) }
        else
            { name: "f" + operation,
              params: [ "f", "x", "y" ],
              body: JsAst.binop(operation, 
                                JsAst.lookup("x"),
                                JsAst.lookup("y")) }
    let liftedBuiltins = unique(firstStep.builtins)
    { ast: addLets @> liftedBuiltins firstStep.ast,
      funcs: (generateFuncs $ liftedBuiltins) + firstStep.funcs }
