import JsAst
import transform
import utils

/*
 * Returns: { ast: ast, funcs: [{ name: name, params: [], body: body }, ...] }
 * Object probably also contains the count and closure ids.  
 */

/* XXX still missing a few things I'm not ready to put straight into JS */
let binops = [ ">", ">=", "<", "<=", "-", "*", "/", "%", "array+", "||", "&&" ]
let unops = [ "!", "unary -" ]

let corefuncs = [ "==", "!=", "+", "$", "@>", "<@", "print", ":", "..", "ref=" ]
let builtins = corefuncs + unops + binops

let unique = (list :: [[Int64]]) =>
    if list.length == 0 then [] else
    if list.length == 1 then
        if utils.in(list:0, ["true", "false", "recur"]) then [] else list
    else
    let rec = recur(list:(1..(list.length-1)))
    if utils.in(list:0, rec + ["true", "false", "recur"]) then 
        rec
    else
        [list:0] + rec

/* TODO closure vars in here */
let listRec = (list :: [Object],
               f :: (Object, [[Int64]], Int64) Object,
               env :: [[Int64]],
               count :: Int64) =>
    ((a :: Object, saved :: Object) =>
        let handled = f(a, env, saved.count)
        { asts: [handled.ast] + saved.asts,
          funcs: handled.funcs + saved.funcs,
          closure: handled.closure + saved.closure,
          builtins: handled.builtins + saved.builtins,
          count: handled.count }) @> list { asts: [],
                                            funcs: [],
                                            closure: [],
                                            builtins: [],
                                            count: count }

let defunc_main = (ast :: Object, env :: [[Int64]], count :: Int64) =>
    if ast.type == "array" then
        let results = listRec(ast.contents, recur, env, count)
        { ast: JsAst.array(results.asts),
          funcs: results.funcs,
          closure: results.closure,
          builtins: results.builtins,
          count: results.count }
    else if ast.type == "call" then
        let args = listRec(ast.args, recur, env, count)
        if args.asts.length == 2 && ast.func.type == "lookup"
                                 && utils.in(ast.func.identifier, binops) then
            { ast: JsAst.binop(ast.func.identifier, args.asts:0, args.asts:1),
              funcs: args.funcs,
              closure: args.closure,
              builtins: args.builtins,
              count: args.count }
        else if args.asts.length == 1 && ast.func.type == "lookup"
                                    && utils.in(ast.func.identifier, unops) then
            { ast: JsAst.unop(ast.func.identifier, args.asts:0),
              funcs: args.funcs,
              closure: args.closure,
              builtins: args.builtins,
              count: args.count }
        else
            let func = recur(ast.func, env, args.count)
            { ast: JsAst.call(JsAst.field_access(func.ast, "f"),
                              [func.ast] + args.asts),
              funcs: func.funcs + args.funcs,
              closure: func.closure + args.closure,
              builtins: func.builtins + args.builtins,
              count: func.count }
    else if ast.type == "field_access" then
        let obj = recur(ast.obj, env, count)
        { ast: JsAst.field_access(obj.ast, ast.field),
          funcs: obj.funcs,
          closure: obj.closure,
          builtins: obj.builtins,
          count: obj.count }
    else if ast.type == "js-assignment" then
        let value = recur(ast.value, env, count)
        let body = recur(ast.body, [ast.identifier] + env, value.count)
        { ast: JsAst.assignment(ast.identifier, value.ast, body.ast),
          funcs: value.funcs + body.funcs,
          closure: value.closure + body.closure,
          builtins: value.builtins + body.builtins,
          count: body.count }
    else if ast.type == "js-conditional" then
        let cond = recur(ast.cond, env, count)
        let thn = recur(ast.thn, env, cond.count)
        let els = recur(ast.els, env, thn.count)
        { ast: JsAst.conditional(cond.ast, thn.ast, els.ast),
          funcs: cond.funcs + thn.funcs + els.funcs,
          closure: cond.closure + thn.closure + els.closure,
          builtins: cond.builtins + thn.builtins + els.builtins,
          count: els.count }
    else if ast.type == "lambda" then
        let body = recur(ast.body, ast.params, count + 1)
        let closureIds = unique(body.closure)
        let newBody = ((x :: [Int64], inner :: Object) => JsAst.assignment(
            x,
            JsAst.field_access(JsAst.lookup("f"), x),
            inner
        )) @> closureIds body.ast
        let closure = ((x :: [Int64]) => 
                            { identifier: x,
                              value: JsAst.lookup(x) }) $ closureIds
        let funcPair = [{ identifier: "f",
                          value: JsAst.lookup("f" + utils.itoa(count)) }]
        { ast: JsAst.object(closure + funcPair),
          funcs: [{ 
              name: "f" + utils.itoa(count),
              params: ["f"] + ast.params,
              body: JsAst.assignment("recur", JsAst.lookup("f"), newBody)
          }] + body.funcs,
          closure: ((x :: [Int64], list :: [[Int64]]) =>
                        if utils.in(x, env) then list 
                                            else [x] + list) @> closureIds [],
          builtins: body.builtins,
          count: body.count }
    else if ast.type == "object" then
        let values = listRec(((x :: Object) => x.value) $ ast.contents,
                             recur,
                             env,
                             count)
        let contents = ((i :: Int64) => 
            { identifier: (ast.contents:i).identifier,
              value: values.asts:i }) $ 0..(ast.contents.length-1)
        { ast: JsAst.object(contents),
          funcs: values.funcs,
          closure: values.closure,
          builtins: values.builtins,
          count: values.count }
    else if ast.type == "lookup" then
        if utils.in(ast.identifier, corefuncs) then
            /* Don't need to close over builtins, as they are defined globally.
             * We do need to create primitive closures for them so that they 
             * can be passed intuitively though.*/
            { ast: JsAst.object([{ identifier: "f", 
                                   value: JsAst.lookup(ast.identifier) }]),
              funcs: [],
              closure: [],
              builtins: [],
              count: count }
        else if utils.in(ast.identifier, unops + binops) then
            /* These builtins can be generated */
            { ast: JsAst.lookup(ast.identifier),
              funcs: [],
              closure: [],
              builtins: [ast.identifier],
              count: count }
        else if !utils.in(ast.identifier, env) then
            { ast: JsAst.lookup(ast.identifier),
              funcs: [],
              closure: [ast.identifier],
              builtins: [],
              count: count }
        else
            { ast: JsAst.lookup(ast.identifier),
              funcs: [],
              closure: [],
              builtins: [],
              count: count }
    else
        /* No other cases can contain functions. XXX should be a number. */
        { ast: JsAst.number(ast.value),
          funcs: [],
          closure: [],
          builtins: [],
          count: count }


(program_as_string :: [Int64]) =>
    let firstStep = defunc_main(transform(program_as_string), [], 0)
    let addLets = (operation :: [Int64], ast :: Object) => 
        { type: "js-assignment",
          identifier: operation,
          value: { type: "object",
                   contents: [{ identifier: "f",
                                value: { type: "lookup",
                                         identifier: "f" + operation } }] },
          body: ast }
    let generateFuncs = (operation :: [Int64]) =>
        if utils.in(operation, unops) then
            { name: "f" + operation,
              params: [ "f", "x" ],
              body: { type: "unop",
                      operation: operation,
                      arg: { type: "lookup",
                             identifier: "x" } } }
        else
            { name: "f" + operation,
              params: [ "f", "x", "y" ],
              body: { type: "binop",
                      operation: operation,
                      left: { type: "lookup",
                              identifier: "x" },
                      right: { type: "lookup",
                               identifier: "y" } } }
    let liftedBuiltins = unique(firstStep.builtins)
    { ast: addLets @> liftedBuiltins firstStep.ast,
      funcs: (generateFuncs $ liftedBuiltins) + firstStep.funcs }
