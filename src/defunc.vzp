import transform
import utils

/*
 * Returns: { ast: ast, funcs: [{ name: name, params: [], body: body }, ...] }
 * Object probably also contains the count and closure ids.  
 */

/* XXX still missing a few things I'm not ready to put straight into JS */
let binops = [ ">", ">=", "<", "<=", "-", "*", "/", "%", "array+", "||", "&&" ]
let unops = [ "!", "unary -" ]

let corefuncs = [ "==", "!=", "+", "$", "@>", "<@", "print", ":", "..", "ref=" ]
let builtins = corefuncs + unops + binops

let unique = (list :: [[Int64]]) =>
    if list.length == 0 then [] else
    if list.length == 1 then
        if utils.in(list:0, ["true", "false", "recur"]) then [] else list
    else
    let rec = recur(list:(1..(list.length-1)))
    if utils.in(list:0, rec + ["true", "false", "recur"]) then 
        rec
    else
        [list:0] + rec

/* TODO closure vars in here */
let listRec = (list :: [Object],
               f :: (Object, [[Int64]], Int64) Object,
               env :: [[Int64]],
               count :: Int64) =>
    ((a :: Object, saved :: Object) =>
        let handled = f(a, env, saved.count)
        { asts: [handled.ast] + saved.asts,
          funcs: handled.funcs + saved.funcs,
          closure: handled.closure + saved.closure,
          builtins: handled.builtins + saved.builtins,
          count: handled.count }) @> list { asts: [],
                                            funcs: [],
                                            closure: [],
                                            builtins: [],
                                            count: count }

let defunc_main = (ast :: Object, env :: [[Int64]], count :: Int64) =>
    if ast.type == "array" then
        let results = listRec(ast.contents, recur, env, count)
        { ast: { type: "array",
                 contents: results.asts },
          funcs: results.funcs,
          closure: results.closure,
          builtins: results.builtins,
          count: results.count }
    else if ast.type == "call" then
        let args = listRec(ast.args, recur, env, count)
        if args.asts.length == 2 && ast.func.type == "lookup"
                                 && utils.in(ast.func.identifier, binops) then
            { ast: { type: "binop",
                     operation: ast.func.identifier,
                     left: args.asts:0,
                     right: args.asts:1 },
              funcs: args.funcs,
              closure: args.closure,
              builtins: args.builtins,
              count: args.count }
        else if args.asts.length == 1 && ast.func.type == "lookup"
                                    && utils.in(ast.func.identifier, unops) then
            { ast: { type: "unop",
                     operation: ast.func.identifier,
                     arg: args.asts:0 },
              funcs: args.funcs,
              closure: args.closure,
              builtins: args.builtins,
              count: args.count }
        else
            let func = recur(ast.func, env, args.count)
            { ast: { type: "call",
                     func: { type: "field_access",
                             obj: func.ast,
                             field: "f" },
                     args: [func.ast] + args.asts },
              funcs: func.funcs + args.funcs,
              closure: func.closure + args.closure,
              builtins: func.builtins + args.builtins,
              count: func.count }
    else if ast.type == "field_access" then
        let obj = recur(ast.obj, env, count)
        { ast: { type: "field_access",
                 obj: obj.ast,
                 field: ast.field },
          funcs: obj.funcs,
          closure: obj.closure,
          builtins: obj.builtins,
          count: obj.count }
    else if ast.type == "js-assignment" then
        let value = recur(ast.value, env, count)
        let body = recur(ast.body, [ast.identifier] + env, value.count)
        { ast: { type: "js-assignment",
                 identifier: ast.identifier,
                 value: value.ast,
                 body: body.ast },
          funcs: value.funcs + body.funcs,
          closure: value.closure + body.closure,
          builtins: value.builtins + body.builtins,
          count: body.count }
    else if ast.type == "js-conditional" then
        let cond = recur(ast.cond, env, count)
        let thn = recur(ast.thn, env, cond.count)
        let els = recur(ast.els, env, thn.count)
        { ast: { type: "js-conditional",
                 cond: cond.ast,
                 thn: thn.ast,
                 els: els.ast },
          funcs: cond.funcs + thn.funcs + els.funcs,
          closure: cond.closure + thn.closure + els.closure,
          builtins: cond.builtins + thn.builtins + els.builtins,
          count: els.count }
    else if ast.type == "lambda" then
        let body = recur(ast.body, ast.params, count + 1)
        let closureIds = unique(body.closure)
        let newBody = ((x :: [Int64], inner :: Object) =>
                            { type: "js-assignment",
                              identifier: x,
                              value: { type: "field_access",
                                       obj: { type: "lookup",
                                              identifier: "f" },
                                       field: x },
                              body: inner }) @> closureIds body.ast
        let closure = ((x :: [Int64]) => 
                            { identifier: x,
                              value: { type: "lookup",
                                       identifier: x } }) $ closureIds
        let funcPair = [{ identifier: "f",
                          value: { type: "lookup", 
                                   identifier: "f" + utils.itoa(count) } }]
        { ast: { type: "object",
                 contents: closure + funcPair },
          funcs: [{ name: "f" + utils.itoa(count),
                    params: ["f"] + ast.params,
                    body: { type: "js-assignment",
                            identifier: "recur",
                            value: { type: "lookup",
                                     identifier: "f" }, /* Closure param */
                            body: newBody } }] + body.funcs,
          closure: ((x :: [Int64], list :: [[Int64]]) =>
                        if utils.in(x, env) then list 
                                            else [x] + list) @> closureIds [],
          builtins: body.builtins,
          count: body.count }
    else if ast.type == "object" then
        let values = listRec(((x :: Object) => x.value) $ ast.contents,
                             recur,
                             env,
                             count)
        let contents = ((i :: Int64) => 
            { identifier: (ast.contents:i).identifier,
              value: values.asts:i }) $ 0..(ast.contents.length-1)
        { ast: { type: "object",
                 contents: contents },
          funcs: values.funcs,
          closure: values.closure,
          builtins: values.builtins,
          count: values.count }
    else if ast.type == "lookup" then
        if utils.in(ast.identifier, corefuncs) then
            /* Don't need to close over builtins, as they are defined globally.
             * We do need to create primitive closures for them so that they 
             * can be passed intuitively though.*/
            { ast: { type: "object",
                     contents: [{ identifier: "f",
                                  value: { type: "lookup",
                                           identifier: ast.identifier } }] },
              funcs: [],
              closure: [],
              builtins: [],
              count: count }
        else if utils.in(ast.identifier, unops + binops) then
            /* These builtins can be generated */
            { ast: ast,
              funcs: [],
              closure: [],
              builtins: [ ast.identifier ],
              count: count }
        else if !utils.in(ast.identifier, env) then
            { ast: ast,
              funcs: [],
              closure: [ast.identifier],
              builtins: [],
              count: count }
        else
            { ast: ast, funcs: [], closure: [], builtins: [], count: count }
    else
        /* No other cases can contain functions */
        { ast: ast, funcs: [], closure: [], builtins: [], count: count }


(program_as_string :: [Int64]) =>
    let firstStep = defunc_main(transform(program_as_string), [], 0)
    let addLets = (operation :: [Int64], ast :: Object) => 
        { type: "js-assignment",
          identifier: operation,
          value: { type: "object",
                   contents: [{ identifier: "f",
                                value: { type: "lookup",
                                         identifier: "f" + operation } }] },
          body: ast }
    let generateFuncs = (operation :: [Int64]) =>
        if utils.in(operation, unops) then
            { name: "f" + operation,
              params: [ "f", "x" ],
              body: { type: "unop",
                      operation: operation,
                      arg: { type: "lookup",
                             identifier: "x" } } }
        else
            { name: "f" + operation,
              params: [ "f", "x", "y" ],
              body: { type: "binop",
                      operation: operation,
                      left: { type: "lookup",
                              identifier: "x" },
                      right: { type: "lookup",
                               identifier: "y" } } }
    let liftedBuiltins = unique(firstStep.builtins)
    { ast: addLets @> liftedBuiltins firstStep.ast,
      funcs: (generateFuncs $ liftedBuiltins) + firstStep.funcs }
