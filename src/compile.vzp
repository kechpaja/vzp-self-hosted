import FunctionWrapper
import IdValuePair
import JsAst
import defunc
import utils

let escape = (id :: [Int64]) =>
    if utils.in(id, ["true", "false"]) then id else
    let f = (c :: Int64) => 
        if utils.isAlnum(c) then [c] else "_" + utils.itoa(c) + "_"
    let g = (a :: [Int64], b :: [Int64]) => a + b
    "_" + (g <@ [] f $ id)

let compile_body = (ast :: JsAst, isBound :: Boolean) =>
    let recTrue = let rf = recur; (x :: JsAst) => rf(x, true)
    let recFalse = let rf = recur; (x :: JsAst) => rf(x, false)

    let wrap = (x :: [Int64]) => if isBound then x else "return " + x + ";"

    /* Main block */
    switch ast <|
        JsAst.array -> wrap("[" + utils.join(recTrue $ that.contents) + "]"),
        JsAst.assignment -> "let " + escape(that.identifier) + "="
            + recTrue(that.value) + ";" + recFalse(that.body),
        JsAst.binop -> if that.operation == ":" then
                wrap(recTrue(that.left) + "[" + recTrue(that.right) + "]")
            else if that.operation == "$" then
                wrap(recTrue(that.right) + ".map(function(x){const y="
                        + recTrue(that.left) + ";return y._f(y,x);})")
            else if that.operation == ".." then
                wrap("b_range(" + recTrue(that.left) + ","
                                + recTrue(that.right) + ")")
            else if that.operation == "==" then
                wrap("(" + recTrue(that.left) + "==="
                         + recTrue(that.right) + ")")
            else if that.operation == "++" then
                wrap(recTrue(that.left) + ".concat(" + recTrue(that.right) +")")
            else if that.operation == "/" then
                wrap("Math.floor(" + recTrue(that.left) + "/" 
                                   + recTrue(that.right) + ")")
            else 
                wrap("(" + recTrue(that.left) + that.operation 
                                              + recTrue(that.right) + ")"),
        JsAst.call -> wrap(recTrue(that.func) + "("
                           + utils.join(recTrue $ that.args) + ")"),
        JsAst.conditional -> "if(" + recTrue(that.cond) + "){" 
            + recFalse(that.thn) + "}else{" + recFalse(that.els) + "}",
        JsAst.field_access -> wrap(recTrue(that.obj) + "." +escape(that.field)),
        JsAst.lookup -> wrap(escape(that.identifier)),
        JsAst.number -> wrap(utils.itoa(that.value)),
        JsAst.object -> let f = (elem :: IdValuePair</JsAst/>) => 
                            escape(elem.identifier) + ":" + recTrue(elem.value)
                        wrap("{" + utils.join(f $ that.contents) + "}"),
        JsAst.unop -> if that.operation == "unary -" then 
                wrap("(-(" + recTrue(that.arg) + "))")
            else if that.operation == "length" then
                wrap(recTrue(that.arg) + ".length")
            else wrap("(" + that.operation + "(" + recTrue(that.arg) + "))")
    |>

let compile_func = (func :: FunctionWrapper) =>
    "function " + escape(func.name) + "(" + utils.join(escape $ func.params)
                + "){" + compile_body(func.body, false) + "}"

(program_as_string :: [Int64]) =>
    let prog = defunc(program_as_string)
    let f = (a :: [Int64], b :: [Int64]) => a + b
    "function b_range(x,y){return Array.from(Array(y>=x?y-x:0),(n,i)=>i+x);}"
        + (f @> (compile_func $ prog.funcs) compile_body(prog.ast, false))
