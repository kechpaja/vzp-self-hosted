import transform
import utils

let escapeId = (id :: [Int64]) =>
    if utils.in(id, ["true", "false"]) then id else
    let f = (c :: Int64) => 
        if utils.isAlnum(c) then [c] else "_" + utils.itoa(c) + "_"
    "_" + ((+) <@ [] f $ id)

let compile_js = (ast :: Object, isBound :: Boolean, depth :: Int64) =>
    let recTrue = let rf = recur; (x :: Object) => rf(x, true, depth + 1)
    let recFalse = let rf = recur; (x :: Object) => rf(x, false, depth + 1)
    let depthId = "_0_" + utils.itoa(depth)

    let wrap = (x :: [Int64]) => if isBound then x else "return " + x + ";"

    /* Main block */
    if ast.type == "array" then
        wrap("[" + utils.join(recTrue $ ast.contents) + "]")
    else if ast.type == "call" then
        wrap(recTrue(ast.func) + "(" + utils.join(recTrue $ ast.args) + ")")
    else if ast.type == "field_access" then
        if ast.field == "length" then /* TODO this will not work long term */
            wrap(recTrue(ast.obj) + ".length")
        else
            wrap(recTrue(ast.obj) + "." + escapeId(ast.field))
    else if ast.type == "js-conditional" then
        "if(" + recTrue(ast.cond) + "){" + recFalse(ast.thn) + "}else{"
                                         + recFalse(ast.els) + "}"
    else if ast.type == "js-assignment" then
        "let " + escapeId(ast.identifier) + "=" + recTrue(ast.value) + ";" 
                                                + recFalse(ast.body)
    else if ast.type == "import" then
        wrap("require('./" + ast.module + ".js').vzpModule")
    else if ast.type == "lambda" then
        wrap("(function () {"
      + "function " + depthId + "(" + utils.join(escapeId $ ast.params) + "){"
                   + "let _recur=" + depthId + ";" + recFalse(ast.body) + "}"
      + "return " + depthId + ";})()")
    else if ast.type == "lookup" then
        wrap(escapeId(ast.identifier))
    else if ast.type == "number" then
        wrap(utils.itoa(ast.value))
    else if ast.type == "object" then
        let f = (elem :: Object) => 
            escapeId(elem.identifier) + ":" + recTrue(elem.value)
        wrap("{" + utils.join(f $ ast.contents) + "}")
    else
        "UNKNOWN" + ast.type

(program_as_string :: [Int64]) =>
    "module.exports={vzpModule:(function(){"
  + compile_js(transform(program_as_string), false, 0)
  + "})()};" /* TODO various args and such */ 
